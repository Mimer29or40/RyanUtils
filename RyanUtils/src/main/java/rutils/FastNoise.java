package rutils;

// MIT License
//
// Copyright(c) 2020 Jordan Peck (jordan.me2@gmail.com)
// Copyright(c) 2020 Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// .'',;:cldxkO00KKXXNNWWWNNXKOkxdollcc::::::;:::ccllloooolllllllllooollc:,'...        ...........',;cldxkO000Okxdlc::;;;,,;;;::cclllllll
// ..',;:ldxO0KXXNNNNNNNNXXK0kxdolcc::::::;;;,,,,,,;;;;;;;;;;:::cclllllc:;'....       ...........',;:ldxO0KXXXK0Okxdolc::;;;;::cllodddddo
// ...',:loxO0KXNNNNNXXKK0Okxdolc::;::::::::;;;,,'''''.....''',;:clllllc:;,'............''''''''',;:loxO0KXNNNNNXK0Okxdollccccllodxxxxxxd
// ....';:ldkO0KXXXKK00Okxdolcc:;;;;;::cclllcc:;;,''..... ....',;clooddolcc:;;;;,,;;;;;::::;;;;;;:cloxk0KXNWWWWWWNXKK0Okxddoooddxxkkkkkxx
// .....';:ldxkOOOOOkxxdolcc:;;;,,,;;:cllooooolcc:;'...      ..,:codxkkkxddooollloooooooollcc:::::clodkO0KXNWWWWWWNNXK00Okxxxxxxxxkkkkxxx
// . ....';:cloddddo___________,,,,;;:clooddddoolc:,...      ..,:ldx__00OOOkkk___kkkkkkxxdollc::::cclodkO0KXXNNNNNNXXK0OOkxxxxxxxxxxxxddd
// .......',;:cccc:|           |,,,;;:cclooddddoll:;'..     ..';cox|  \KKK000|   |KK00OOkxdocc___;::clldxxkO0KKKKK00Okkxdddddddddddddddoo
// .......'',,,,,''|   ________|',,;;::cclloooooolc:;'......___:ldk|   \KK000|   |XKKK0Okxolc|   |;;::cclodxxkkkkxxdoolllcclllooodddooooo
// ''......''''....|   |  ....'',,,,;;;::cclloooollc:;,''.'|   |oxk|    \OOO0|   |KKK00Oxdoll|___|;;;;;::ccllllllcc::;;,,;;;:cclloooooooo
// ;;,''.......... |   |_____',,;;;____:___cllo________.___|   |___|     \xkk|   |KK_______ool___:::;________;;;_______...'',;;:ccclllloo
// c:;,''......... |         |:::/     '   |lo/        |           |      \dx|   |0/       \d|   |cc/        |'/       \......',,;;:ccllo
// ol:;,'..........|    _____|ll/    __    |o/   ______|____    ___|   |   \o|   |/   ___   \|   |o/   ______|/   ___   \ .......'',;:clo
// dlc;,...........|   |::clooo|    /  |   |x\___   \KXKKK0|   |dol|   |\   \|   |   |   |   |   |d\___   \..|   |  /   /       ....',:cl
// xoc;'...  .....'|   |llodddd|    \__|   |_____\   \KKK0O|   |lc:|   |'\       |   |___|   |   |_____\   \.|   |_/___/...      ...',;:c
// dlc;'... ....',;|   |oddddddo\          |          |Okkx|   |::;|   |..\      |\         /|   |          | \         |...    ....',;:c
// ol:,'.......',:c|___|xxxddollc\_____,___|_________/ddoll|___|,,,|___|...\_____|:\ ______/l|___|_________/...\________|'........',;::cc
// c:;'.......';:codxxkkkkxxolc::;::clodxkOO0OOkkxdollc::;;,,''''',,,,''''''''''',,'''''',;:loxkkOOkxol:;,'''',,;:ccllcc:;,'''''',;::ccll
// ;,'.......',:codxkOO0OOkxdlc:;,,;;:cldxxkkxxdolc:;;,,''.....'',;;:::;;,,,'''''........,;cldkO0KK0Okdoc::;;::cloodddoolc:;;;;;::ccllooo
// .........',;:lodxOO0000Okdoc:,,',,;:clloddoolc:;,''.......'',;:clooollc:;;,,''.......',:ldkOKXNNXX0Oxdolllloddxxxxxxdolccccccllooodddd
// .    .....';:cldxkO0000Okxol:;,''',,;::cccc:;,,'.......'',;:cldxxkkxxdolc:;;,'.......';coxOKXNWWWNXKOkxddddxxkkkkkkxdoollllooddxxxxkkk
//       ....',;:codxkO000OOxdoc:;,''',,,;;;;,''.......',,;:clodkO00000Okxolc::;,,''..',;:ldxOKXNWWWNNK0OkkkkkkkkkkkxxddooooodxxkOOOOO000
//       ....',;;clodxkkOOOkkdolc:;,,,,,,,,'..........,;:clodxkO0KKXKK0Okxdolcc::;;,,,;;:codkO0XXNNNNXKK0OOOOOkkkkxxdoollloodxkO0KKKXXXXX
//
// VERSION: 1.0.1
// https://github.com/Auburn/FastNoise

// To switch between using floats or doubles for input position,
// perform a file-wide replace on the following strings (including /*FNLfloat*/)
// /*FNLfloat*/ float
// /*FNLfloat*/ double

import rutils.interpolator.Interpolator;

public class FastNoise
{
    public enum NoiseType
    {
        OpenSimplex2,
        OpenSimplex2S,
        Cellular,
        Perlin,
        ValueCubic,
        Value
    }
    
    public enum RotationType3D
    {
        None,
        ImproveXYPlanes,
        ImproveXZPlanes
    }
    
    public enum FractalType
    {
        None,
        FBm,
        Ridged,
        PingPong,
        DomainWarpProgressive,
        DomainWarpIndependent
    }
    
    public enum CellularDistanceFunction
    {
        Euclidean,
        EuclideanSq,
        Manhattan,
        Hybrid
    }
    
    public enum CellularReturnType
    {
        CellValue,
        Distance,
        Distance2,
        Distance2Add,
        Distance2Sub,
        Distance2Mul,
        Distance2Div
    }
    
    public enum DomainWarpType
    {
        OpenSimplex2,
        OpenSimplex2Reduced,
        BasicGrid
    }
    
    private enum TransformType3D
    {
        None,
        ImproveXYPlanes,
        ImproveXZPlanes,
        DefaultOpenSimplex2
    }
    
    private int             mSeed            = 1337;
    private double          mFrequency       = 0.01f;
    private NoiseType       mNoiseType       = NoiseType.OpenSimplex2;
    private RotationType3D  mRotationType3D  = RotationType3D.None;
    private TransformType3D mTransformType3D = TransformType3D.DefaultOpenSimplex2;
    
    private FractalType mFractalType      = FractalType.None;
    private int         mOctaves          = 3;
    private double      mLacunarity       = 2.0f;
    private double      mGain             = 0.5f;
    private double      mWeightedStrength = 0.0f;
    private double      mPingPongStrength = 2.0f;
    
    private double mFractalBounding = 1 / 1.75f;
    
    private CellularDistanceFunction mCellularDistanceFunction = CellularDistanceFunction.EuclideanSq;
    private CellularReturnType       mCellularReturnType       = CellularReturnType.Distance;
    private double                   mCellularJitterModifier   = 1.0f;
    
    private DomainWarpType  mDomainWarpType      = DomainWarpType.OpenSimplex2;
    private TransformType3D mWarpTransformType3D = TransformType3D.DefaultOpenSimplex2;
    private double          mDomainWarpAmp       = 1.0f;
    
    /**
     * Create new FastNoise object with default seed
     */
    public FastNoise() { }
    
    /**
     * Create new FastNoise object with specified seed
     */
    public FastNoise(int seed)
    {
        setSeed(seed);
    }
    
    /**
     * Sets seed used for all noise types
     * <p>
     * Default: 1337
     */
    public void setSeed(int seed)
    {
        this.mSeed = seed;
    }
    
    /**
     * Sets frequency for all noise types
     * <p>
     * Default: 0.01
     */
    public void setFrequency(double frequency)
    {
        this.mFrequency = frequency;
    }
    
    /**
     * Sets noise algorithm used for GetNoise(...)
     * <p>
     * Default: {@link NoiseType#OpenSimplex2 OpenSimplex2}
     */
    public void setNoiseType(NoiseType noiseType)
    {
        this.mNoiseType = noiseType;
        updateTransformType3D();
    }
    
    /**
     * Sets domain rotation type for 3D Noise and 3D DomainWarp.
     * Can aid in reducing directional artifacts when sampling a 2D plane in 3D
     * <p>
     * Default: {@link RotationType3D#None None}
     */
    public void setRotationType3D(RotationType3D rotationType3D)
    {
        this.mRotationType3D = rotationType3D;
        updateTransformType3D();
        updateWarpTransformType3D();
    }
    
    /**
     * Sets method for combining octaves in all fractal noise types
     * <p>
     * Note: Fractal.DomainWarp... only affects DomainWarp(...)
     * <p>
     * Default: {@link FractalType#None None}
     */
    public void setFractalType(FractalType fractalType)
    {
        this.mFractalType = fractalType;
    }
    
    /**
     * Sets octave count for all fractal noise types
     * <p>
     * Default: 3
     */
    public void setFractalOctaves(int octaves)
    {
        this.mOctaves = octaves;
        calculateFractalBounding();
    }
    
    /**
     * Sets octave lacunarity for all fractal noise types
     * <p>
     * Default: 2.0
     */
    public void setFractalLacunarity(double lacunarity)
    {
        this.mLacunarity = lacunarity;
    }
    
    /**
     * Sets octave gain for all fractal noise types
     * <p>
     * Default: 0.5
     */
    public void setFractalGain(double gain)
    {
        this.mGain = gain;
        calculateFractalBounding();
    }
    
    /**
     * Sets octave weighting for all none DomainWarp fractal types
     * <p>
     * Note: Keep between 0...1 to maintain -1...1 output bounding
     * <p>
     * Default: 0.0
     */
    public void setFractalWeightedStrength(double weightedStrength)
    {
        this.mWeightedStrength = weightedStrength;
    }
    
    /**
     * Sets strength of the fractal ping pong effect
     * <p>
     * Default: 2.0
     */
    public void setFractalPingPongStrength(double pingPongStrength)
    {
        this.mPingPongStrength = pingPongStrength;
    }
    
    /**
     * Sets distance function used in cellular noise calculations
     * <p>
     * Default: {@link CellularDistanceFunction#EuclideanSq EuclideanSq}
     */
    public void setCellularDistanceFunction(CellularDistanceFunction cellularDistanceFunction)
    {
        this.mCellularDistanceFunction = cellularDistanceFunction;
    }
    
    /**
     * Sets return type from cellular noise calculations
     * <p>
     * Default: {@link CellularReturnType#Distance Distance}
     */
    public void setCellularReturnType(CellularReturnType cellularReturnType)
    {
        this.mCellularReturnType = cellularReturnType;
    }
    
    /**
     * Sets the maximum distance a cellular point can move from it's grid position
     * <p>
     * Note: Setting this higher than 1 will cause artifacts
     * <p>
     * Default: 1.0
     */
    public void setCellularJitter(double cellularJitter)
    {
        this.mCellularJitterModifier = cellularJitter;
    }
    
    /**
     * Sets the warp algorithm when using DomainWarp(...)
     * <p>
     * Default: {@link DomainWarpType#OpenSimplex2 OpenSimplex2}
     */
    public void setDomainWarpType(DomainWarpType domainWarpType)
    {
        this.mDomainWarpType = domainWarpType;
        updateWarpTransformType3D();
    }
    
    /**
     * Sets the maximum warp distance from original position when using DomainWarp(...)
     * <p>
     * Default: 1.0
     */
    public void setDomainWarpAmp(double domainWarpAmp)
    {
        this.mDomainWarpAmp = domainWarpAmp;
    }
    
    /**
     * 2D noise at given position using current settings
     *
     * @return Noise output bounded between -1...1
     */
    public double getNoise(double x, double y)
    {
        x *= this.mFrequency;
        y *= this.mFrequency;
        
        switch (this.mNoiseType)
        {
            case OpenSimplex2, OpenSimplex2S -> {
                final double SQRT3 = 1.7320508075688772935274463415059;
                final double F2    = 0.5 * (SQRT3 - 1);
                double       t     = (x + y) * F2;
                x += t;
                y += t;
            }
        }
        
        return switch (this.mFractalType)
                {
                    default -> genNoiseSingle(this.mSeed, x, y);
                    case FBm -> genFractalFBm(x, y);
                    case Ridged -> genFractalRidged(x, y);
                    case PingPong -> genFractalPingPong(x, y);
                };
    }
    
    /**
     * 3D noise at given position using current settings
     *
     * @return Noise output bounded between -1...1
     */
    public double getNoise(double x, double y, double z)
    {
        x *= this.mFrequency;
        y *= this.mFrequency;
        z *= this.mFrequency;
        
        switch (this.mTransformType3D)
        {
            case ImproveXYPlanes -> {
                double xy = x + y;
                double s2 = xy * -0.211324865405187;
                z *= 0.577350269189626;
                x += s2 - z;
                y = y + s2 - z;
                z += xy * 0.577350269189626;
            }
            case ImproveXZPlanes -> {
                double xz = x + z;
                double s2 = xz * -0.211324865405187;
                y *= 0.577350269189626;
                x += s2 - y;
                z += s2 - y;
                y += xz * 0.577350269189626;
            }
            case DefaultOpenSimplex2 -> {
                final double R3 = 2.0 / 3.0;
                double       r  = (x + y + z) * R3; // Rotation, not skew
                x = r - x;
                y = r - y;
                z = r - z;
            }
        }
        
        return switch (this.mFractalType)
                {
                    default -> genNoiseSingle(this.mSeed, x, y, z);
                    case FBm -> genFractalFBm(x, y, z);
                    case Ridged -> genFractalRidged(x, y, z);
                    case PingPong -> genFractalPingPong(x, y, z);
                };
    }
    
    /**
     * 2D warps the input position using current domain warp settings
     * <p>
     * Example usage with GetNoise
     * <code>DomainWarp(coord);
     * noise = getNoise(x, y);</code>
     */
    public void domainWarp(Vector2 coord)
    {
        switch (this.mFractalType)
        {
            default -> domainWarpSingle(coord);
            case DomainWarpProgressive -> domainWarpFractalProgressive(coord);
            case DomainWarpIndependent -> domainWarpFractalIndependent(coord);
        }
    }
    
    /**
     * 3D warps the input position using current domain warp settings
     * <p>
     * Example usage with GetNoise
     * <code>DomainWarp(coord);
     * noise = getNoise(x, y, z);</code>
     */
    public void domainWarp(Vector3 coord)
    {
        switch (mFractalType)
        {
            default -> domainWarpSingle(coord);
            case DomainWarpProgressive -> domainWarpFractalProgressive(coord);
            case DomainWarpIndependent -> domainWarpFractalIndependent(coord);
        }
    }
    
    private static final double[] GRAD2 = {
            +0.130526192220052, +0.991444861373810, +0.382683432365090, +0.923879532511287, +0.608761429008721, +0.793353340291235, +0.793353340291235, +0.608761429008721,
            +0.923879532511287, +0.382683432365090, +0.991444861373810, +0.130526192220051, +0.991444861373810, -0.130526192220051, +0.923879532511287, -0.382683432365090,
            +0.793353340291235, -0.608761429008720, +0.608761429008721, -0.793353340291235, +0.382683432365090, -0.923879532511287, +0.130526192220052, -0.991444861373810,
            -0.130526192220052, -0.991444861373810, -0.382683432365090, -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
            -0.923879532511287, -0.382683432365090, -0.991444861373810, -0.130526192220052, -0.991444861373810, +0.130526192220051, -0.923879532511287, +0.382683432365090,
            -0.793353340291235, +0.608761429008721, -0.608761429008721, +0.793353340291235, -0.382683432365090, +0.923879532511287, -0.130526192220052, +0.991444861373810,
            +0.130526192220052, +0.991444861373810, +0.382683432365090, +0.923879532511287, +0.608761429008721, +0.793353340291235, +0.793353340291235, +0.608761429008721,
            +0.923879532511287, +0.382683432365090, +0.991444861373810, +0.130526192220051, +0.991444861373810, -0.130526192220051, +0.923879532511287, -0.382683432365090,
            +0.793353340291235, -0.608761429008720, +0.608761429008721, -0.793353340291235, +0.382683432365090, -0.923879532511287, +0.130526192220052, -0.991444861373810,
            -0.130526192220052, -0.991444861373810, -0.382683432365090, -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
            -0.923879532511287, -0.382683432365090, -0.991444861373810, -0.130526192220052, -0.991444861373810, +0.130526192220051, -0.923879532511287, +0.382683432365090,
            -0.793353340291235, +0.608761429008721, -0.608761429008721, +0.793353340291235, -0.382683432365090, +0.923879532511287, -0.130526192220052, +0.991444861373810,
            +0.130526192220052, +0.991444861373810, +0.382683432365090, +0.923879532511287, +0.608761429008721, +0.793353340291235, +0.793353340291235, +0.608761429008721,
            +0.923879532511287, +0.382683432365090, +0.991444861373810, +0.130526192220051, +0.991444861373810, -0.130526192220051, +0.923879532511287, -0.382683432365090,
            +0.793353340291235, -0.608761429008720, +0.608761429008721, -0.793353340291235, +0.382683432365090, -0.923879532511287, +0.130526192220052, -0.991444861373810,
            -0.130526192220052, -0.991444861373810, -0.382683432365090, -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
            -0.923879532511287, -0.382683432365090, -0.991444861373810, -0.130526192220052, -0.991444861373810, +0.130526192220051, -0.923879532511287, +0.382683432365090,
            -0.793353340291235, +0.608761429008721, -0.608761429008721, +0.793353340291235, -0.382683432365090, +0.923879532511287, -0.130526192220052, +0.991444861373810,
            +0.130526192220052, +0.991444861373810, +0.382683432365090, +0.923879532511287, +0.608761429008721, +0.793353340291235, +0.793353340291235, +0.608761429008721,
            +0.923879532511287, +0.382683432365090, +0.991444861373810, +0.130526192220051, +0.991444861373810, -0.130526192220051, +0.923879532511287, -0.382683432365090,
            +0.793353340291235, -0.608761429008720, +0.608761429008721, -0.793353340291235, +0.382683432365090, -0.923879532511287, +0.130526192220052, -0.991444861373810,
            -0.130526192220052, -0.991444861373810, -0.382683432365090, -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
            -0.923879532511287, -0.382683432365090, -0.991444861373810, -0.130526192220052, -0.991444861373810, +0.130526192220051, -0.923879532511287, +0.382683432365090,
            -0.793353340291235, +0.608761429008721, -0.608761429008721, +0.793353340291235, -0.382683432365090, +0.923879532511287, -0.130526192220052, +0.991444861373810,
            +0.130526192220052, +0.991444861373810, +0.382683432365090, +0.923879532511287, +0.608761429008721, +0.793353340291235, +0.793353340291235, +0.608761429008721,
            +0.923879532511287, +0.382683432365090, +0.991444861373810, +0.130526192220051, +0.991444861373810, -0.130526192220051, +0.923879532511287, -0.382683432365090,
            +0.793353340291235, -0.608761429008720, +0.608761429008721, -0.793353340291235, +0.382683432365090, -0.923879532511287, +0.130526192220052, -0.991444861373810,
            -0.130526192220052, -0.991444861373810, -0.382683432365090, -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
            -0.923879532511287, -0.382683432365090, -0.991444861373810, -0.130526192220052, -0.991444861373810, +0.130526192220051, -0.923879532511287, +0.382683432365090,
            -0.793353340291235, +0.608761429008721, -0.608761429008721, +0.793353340291235, -0.382683432365090, +0.923879532511287, -0.130526192220052, +0.991444861373810,
            +0.382683432365090, +0.923879532511287, +0.923879532511287, +0.382683432365090, +0.923879532511287, -0.382683432365090, +0.382683432365090, -0.923879532511287,
            -0.382683432365090, -0.923879532511287, -0.923879532511287, -0.382683432365090, -0.923879532511287, +0.382683432365090, -0.382683432365090, +0.923879532511287
    };
    
    private static final double[] VEC2 = {
            -0.2700222198, -0.9628540911, +0.3863092627, -0.9223693152, +0.0444485900, -0.9990116730, -0.5992523158, -0.8005602176, -0.7819280288, +0.6233687174, +0.9464672271, +0.3227999196, -0.6514146797, -0.7587218957, +0.9378472289, +0.3470483760,
            -0.8497875957, -0.5271252623, -0.8790425920, +0.4767432447, -0.8923002880, -0.4514423508, -0.3798444340, -0.9250503802, -0.9951650832, +0.0982163789, +0.7724397808, -0.6350880136, +0.7573283322, -0.6530343002, -0.9928004525, -0.1197800550,
            -0.0532665713, +0.9985803285, +0.9754253726, -0.2203300762, -0.7665018163, +0.6422421394, +0.9916367060, +0.1290606184, -0.9946968380, +0.1028503788, -0.5379205513, -0.8429955400, +0.5022815471, -0.8647041387, +0.4559821461, -0.8899889226,
            -0.8659131224, -0.5001944266, +0.0879458407, -0.9961252577, -0.5051684983, +0.8630207346, +0.7753185226, -0.6315704146, -0.6921944612, +0.7217110418, -0.5191659449, -0.8546734591, +0.8978622882, -0.4402764035, -0.1706774107, +0.9853269617,
            -0.9353430106, -0.3537420705, -0.9992404798, +0.0389674679, -0.2882064021, -0.9575683108, -0.9663811329, +0.2571137995, -0.8759714238, -0.4823630009, -0.8303123018, -0.5572983775, +0.0511013375, -0.9986934731, -0.8558373281, -0.5172450752,
            +0.0988702528, +0.9951003332, +0.9189016087, +0.3944867976, -0.2439375892, -0.9697909324, -0.8121409387, -0.5834613061, -0.9910431363, +0.1335421355, +0.8492423985, -0.5280031709, -0.9717838994, -0.2358729591, +0.9949457207, +0.1004142068,
            +0.6241065508, -0.7813392434, +0.6629103070, +0.7486988212, -0.7197418176, +0.6942418282, -0.8143370775, -0.5803922158, +0.1045210540, -0.9945226741, -0.1065926113, -0.9943027784, +0.4457996840, -0.8951327509, +0.1055474060, +0.9944142724,
            -0.9927902670, +0.1198644477, -0.8334366408, +0.5526150250, +0.9115561563, -0.4111755999, +0.8285544909, -0.5599084351, +0.7217097654, -0.6921957921, +0.4940492677, -0.8694339084, -0.3652321272, -0.9309164803, -0.9696606758, +0.2444548501,
            +0.0892550973, -0.9960087990, +0.5354071276, -0.8445941083, -0.1053576186, +0.9944343981, -0.9890284586, +0.1477251101, +0.0048561049, +0.9999882091, +0.9885598478, +0.1508291331, +0.9286129562, -0.3710498316, -0.5832393863, -0.8123003252,
            +0.3015207509, +0.9534596146, -0.9575110528, +0.2883965738, +0.9715802154, -0.2367105511, +0.2299817920, +0.9731949318, +0.9557638160, -0.2941352207, +0.7409561160, +0.6715534485, -0.9971513787, -0.0754263076, +0.6905710663, -0.7232645452,
            -0.2907137030, -0.9568100872, +0.5912777791, -0.8064679708, -0.9454592212, -0.3257404810, +0.6664455681, +0.7455536900, +0.6236134912, +0.7817328275, +0.9126993851, -0.4086316587, -0.8191762011, +0.5735419353, -0.8812745759, -0.4726046147,
            +0.9953313627, +0.0965167265, +0.9855650846, -0.1692969699, -0.8495980887, +0.5274306472, +0.6174853946, -0.7865823463, +0.8508156371, +0.5254643200, +0.9985032451, -0.0546924992, +0.1971371563, -0.9803759185, +0.6607855748, -0.7505747292,
            -0.0309749406, +0.9995201614, -0.6731660801, +0.7394913310, -0.7195018362, -0.6944905383, +0.9727511689, +0.2318515979, +0.9997059088, -0.0242506907, +0.4421787429, -0.8969269532, +0.9981350961, -0.0610436730, -0.9173660799, -0.3980445648,
            -0.8150056635, -0.5794529907, -0.8789331304, +0.4769450202, +0.0158605829, +0.9998742130, -0.8095464474, +0.5870558317, -0.9165898907, -0.3998286786, -0.8023542565, +0.5968480938, -0.5176737917, +0.8555780767, -0.8154407307, -0.5788405779,
            +0.4022010347, -0.9155513791, -0.9052556868, -0.4248672045, +0.7317445619, +0.6815789728, -0.5647632201, -0.8252529947, -0.8403276335, -0.5420788397, -0.9314281527, +0.3639252620, +0.5238198472, +0.8518290719, +0.7432803869, -0.6689800195,
            -0.9853715610, -0.1704197369, +0.4601468731, +0.8878428100, +0.8258554040, +0.5638819483, +0.6182366099, +0.7859920446, +0.8331502863, -0.5530466530, +0.1500307506, +0.9886813308, -0.6623303690, -0.7492119075, -0.6685986640, +0.7436234440,
            +0.7025606278, +0.7116238924, -0.5419389763, -0.8404178401, -0.3388616456, +0.9408362159, +0.8331530315, +0.5530425174, -0.2989720662, -0.9542618632, +0.2638522993, +0.9645630949, +0.1241087390, -0.9922686234, -0.7282649308, -0.6852956957,
            +0.6962500149, +0.7177993569, -0.9183535368, +0.3957610156, -0.6326102274, -0.7744703352, -0.9331891859, -0.3593855080, -0.1153779357, -0.9933216659, +0.9514974788, -0.3076565421, -0.0898797744, -0.9959526224, +0.6678496916, +0.7442961705,
            +0.7952400393, -0.6062947138, -0.6462007402, -0.7631674805, -0.2733598753, +0.9619118351, +0.9669590226, -0.2549318510, -0.9792894595, +0.2024651934, -0.5369502995, -0.8436138784, -0.2700364710, -0.9628500944, -0.6400277131, +0.7683518247,
            -0.7854537493, -0.6189203566, +0.0600590538, -0.9981948257, -0.0245577037, +0.9996984141, -0.6598362300, +0.7514094420, -0.6253894466, -0.7803127835, -0.6210408851, -0.7837781695, +0.8348888491, +0.5504185768, -0.1592275245, +0.9872419133,
            +0.8367622488, +0.5475663786, -0.8675753916, -0.4973056806, -0.2022662628, -0.9793305667, +0.9399189937, +0.3413975472, +0.9877404807, -0.1561049093, -0.9034455656, +0.4287028224, +0.1269804218, -0.9919052235, -0.3819600854, +0.9241788210,
            +0.9754625894, +0.2201652486, -0.3204015856, -0.9472818081, -0.9874760884, +0.1577687387, +0.0253534847, -0.9996785487, +0.4835130794, -0.8753371362, -0.2850799925, -0.9585037287, -0.0680551600, -0.9976815600, -0.7885244045, -0.6150034663,
            +0.3185392127, -0.9479096845, +0.8880043089, +0.4598351306, +0.6476921488, -0.7619021462, +0.9820241299, +0.1887554194, +0.9357275128, -0.3527237187, -0.8894895414, +0.4569555293, +0.7922791302, +0.6101588153, +0.7483818261, +0.6632681526,
            -0.7288929755, -0.6846276581, +0.8729032783, -0.4878932944, +0.8288345784, +0.5594937369, +0.0807456707, +0.9967347374, +0.9799148216, -0.1994165048, -0.5807306730, -0.8140957471, -0.4700049791, -0.8826637636, +0.2409492979, +0.9705377045,
            +0.9437816757, -0.3305694308, -0.8927998638, -0.4504535528, -0.8069622304, +0.5906030467, +0.0625897316, +0.9980393407, -0.9312597469, +0.3643559849, +0.5777449785, +0.8162173362, -0.3360095855, -0.9418585660, +0.6979320750, -0.7161639607,
            -0.0020081572, -0.9999979837, -0.1827294312, -0.9831632392, -0.6523911722, +0.7578824173, -0.4302626911, -0.9027037258, -0.9985126289, -0.0545209125, -0.0102810217, -0.9999471489, -0.4946071129, +0.8691166802, -0.2999350194, +0.9539596344,
            +0.8165471961, +0.5772786819, +0.2697460475, +0.9629314980, -0.7306287391, -0.6827749597, -0.7590952064, -0.6509796216, -0.9070538530, +0.4210146171, -0.5104861064, -0.8598860013, +0.8613350597, +0.5080373165, +0.5007881595, -0.8655698812,
            -0.6541581520, +0.7563577938, -0.8382755311, -0.5452468560, +0.6940070834, +0.7199681717, +0.0695093603, +0.9975812994, +0.1702942185, -0.9853932612, +0.2695973274, +0.9629731466, +0.5519612192, -0.8338697815, +0.2256574870, -0.9742067022,
            +0.4215262855, -0.9068161835, +0.4881873305, -0.8727388672, -0.3683854996, -0.9296731273, -0.9825390578, +0.1860564427, +0.8125647100, +0.5828709909, +0.3196460933, -0.9475370046, +0.9570913859, +0.2897862643, -0.6876655497, -0.7260276109,
            -0.9988770922, -0.0473767310, -0.1250179027, +0.9921544860, -0.8280133617, +0.5607083670, +0.9324863769, -0.3612051451, +0.6394653183, +0.7688199442, -0.0162384706, -0.9998681473, -0.9955014666, -0.0947461345, -0.8145331500, +0.5801170120,
            +0.4037327978, -0.9148769469, +0.9944263371, +0.1054336766, -0.1624711654, +0.9867132919, -0.9949487814, -0.1003838750, -0.6995302564, +0.7146029809, +0.5263414922, -0.8502732700, -0.5395221479, +0.8419714080, +0.6579370318, +0.7530729462,
            +0.0142675884, -0.9998982128, -0.6734383991, +0.7392433447, +0.6394120980, -0.7688642071, +0.9211571421, +0.3891908523, -0.1466372140, -0.9891903394, -0.7823180980, +0.6228791163, -0.5039610839, -0.8637263605, -0.7743120191, -0.6328039957
    };
    
    private static final double[] GRAD3 = {
            +0, +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0,
            +1, +0, +1, +0, -1, +0, +1, +0, +1, +0, -1, +0, -1, +0, -1, +0,
            +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0, +0,
            +0, +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0,
            +1, +0, +1, +0, -1, +0, +1, +0, +1, +0, -1, +0, -1, +0, -1, +0,
            +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0, +0,
            +0, +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0,
            +1, +0, +1, +0, -1, +0, +1, +0, +1, +0, -1, +0, -1, +0, -1, +0,
            +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0, +0,
            +0, +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0,
            +1, +0, +1, +0, -1, +0, +1, +0, +1, +0, -1, +0, -1, +0, -1, +0,
            +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0, +0,
            +0, +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0,
            +1, +0, +1, +0, -1, +0, +1, +0, +1, +0, -1, +0, -1, +0, -1, +0,
            +1, +1, +0, +0, -1, +1, +0, +0, +1, -1, +0, +0, -1, -1, +0, +0,
            +1, +1, +0, +0, +0, -1, +1, +0, -1, +1, +0, +0, +0, -1, -1, +0
    };
    
    private static final double[] VEC3 = {
            -0.7292736885, -0.6618439697, +0.1735581948, +0, +0.7902920810, -0.5480887466, -0.2739291014, +0, +0.7217578935, +0.6226212466, -0.3023380997, +0, +0.5656831370, -0.8208298145, -0.0790000257, +0,
            +0.7600490340, -0.5555979497, -0.3370999617, +0, +0.3713945616, +0.5011264475, +0.7816254623, +0, -0.1277062463, -0.4254438999, -0.8959289049, +0, -0.2881560924, -0.5815838982, +0.7607405838, +0,
            +0.5849561111, -0.6628202390, -0.4674352136, +0, +0.3307171170, +0.0391653737, +0.9429168900, +0, +0.8712121778, -0.4113374369, -0.2679381538, +0, +0.5809810150, +0.7021915846, +0.4115677815, +0,
            +0.5037568730, +0.6330056931, -0.5878203852, +0, +0.4493712205, +0.6013901950, +0.6606022552, +0, -0.6878403724, +0.0901889080, -0.7202371714, +0, -0.5958956522, -0.6469350577, +0.4757976490, +0,
            -0.5127052122, +0.1946921978, -0.8361987284, +0, -0.9911507140, -0.0541027646, -0.1212153153, +0, -0.2149721042, +0.9720882117, -0.0939760774, +0, -0.7518650936, -0.5428057603, +0.3742469607, +0,
            +0.5237068895, +0.8516377189, -0.0210781783, +0, +0.6333504779, +0.1926167129, -0.7495104896, +0, -0.0678824160, +0.3998305789, +0.9140719259, +0, -0.5538628599, -0.4729896695, -0.6852128902, +0,
            -0.7261455366, -0.5911990757, +0.3509933228, +0, -0.9229274730, -0.1782808786, +0.3412049336, +0, -0.6968815002, +0.6511274338, +0.3006480328, +0, +0.9608044783, -0.2098363234, -0.1811724921, +0,
            +0.0681714606, -0.9743405129, +0.2145069156, +0, -0.3577285196, -0.6697087264, -0.6507845481, +0, -0.1868621131, +0.7648617052, -0.6164974636, +0, -0.6541697588, +0.3967914832, +0.6439087246, +0,
            +0.6993340405, -0.6164538506, +0.3618239211, +0, -0.1546665730, +0.6291283928, +0.7617583057, +0, -0.6841612949, -0.2580482182, -0.6821542638, +0, +0.5383980957, +0.4258654885, +0.7271630328, +0,
            -0.5026987823, -0.7939832935, -0.3418836993, +0, +0.3202971715, +0.2834415347, +0.9039195862, +0, +0.8683227101, -0.0003762656, -0.4959995258, +0, +0.7911200310, -0.0851104574, +0.6057105799, +0,
            -0.0401101605, -0.4397248749, +0.8972364289, +0, +0.9145119870, +0.3579346169, -0.1885487608, +0, -0.9612039066, -0.2756484276, +0.0102466692, +0, +0.6510361721, -0.2877799159, -0.7023778346, +0,
            -0.2041786351, +0.7365237271, +0.6448595850, +0, -0.7718263711, +0.3790626912, +0.5104855816, +0, -0.3060082741, -0.7692987727, +0.5608371729, +0, +0.4540073410, -0.5024843065, +0.7357899537, +0,
            +0.4816795475, +0.6021208291, -0.6367380315, +0, +0.6961980360, -0.3222197429, +0.6414691970, +0, -0.6532160499, -0.6781148932, +0.3368515753, +0, +0.5089301236, -0.6154662304, -0.6018234363, +0,
            -0.1635919754, -0.9133604627, -0.3728408920, +0, +0.5240801900, -0.8437664109, +0.1157505864, +0, +0.5902587356, +0.4983817807, -0.6349883666, +0, +0.5863227872, +0.4947647450, +0.6414307729, +0,
            +0.6779335087, +0.2341345225, +0.6968408593, +0, +0.7177054540, -0.6858979348, +0.1201786310, +0, -0.5328819713, -0.5205125012, +0.6671608058, +0, -0.8654874251, -0.0700727088, -0.4960053754, +0,
            -0.2861810166, +0.7952089234, +0.5345495242, +0, -0.0484952963, +0.9810836427, -0.1874115585, +0, -0.6358521667, +0.6058348682, +0.4781800233, +0, +0.6254794696, -0.2861619734, +0.7258696564, +0,
            -0.2585259868, +0.5061949264, -0.8227581726, +0, +0.0213630670, +0.5064016808, -0.8620330371, +0, +0.2001117730, +0.8599263484, +0.4695550591, +0, +0.4743561372, +0.6014985084, -0.6427953014, +0,
            +0.6622993731, -0.5202474575, -0.5391679918, +0, +0.0808497281, -0.6532720452, +0.7527940996, +0, -0.6893687501, +0.0592860349, +0.7219805347, +0, -0.1121887082, -0.9673185067, +0.2273952515, +0,
            +0.7344116094, +0.5979668656, -0.3210532909, +0, +0.5789393460, -0.2488849713, +0.7764570201, +0, +0.6988182827, +0.3557169806, -0.6205791146, +0, -0.8636845529, -0.2748771249, -0.4224826141, +0,
            -0.4247027957, -0.4640880967, +0.7773350460, +0, +0.5257722489, -0.8427017621, +0.1158329937, +0, +0.9343830603, +0.3163024720, -0.1639543925, +0, -0.1016836419, -0.8057303073, -0.5834887393, +0,
            -0.6529238969, +0.5060212600, -0.5635892736, +0, -0.2465286160, -0.9668205684, -0.0669449749, +0, -0.9776897119, -0.2099250524, -0.0073688253, +0, +0.7736893337, +0.5734244712, +0.2694238123, +0,
            -0.6095087895, +0.4995678998, +0.6155736747, +0, +0.5794535482, +0.7434546771, +0.3339292269, +0, -0.8226211154, +0.0814258185, +0.5627293636, +0, -0.5103854830, +0.4703667658, +0.7199039967, +0,
            -0.5764971849, -0.0723165627, -0.8138926898, +0, +0.7250628870, +0.3949971505, -0.5641463116, +0, -0.1525424005, +0.4860840828, -0.8604958341, +0, -0.5550976208, -0.4957820792, +0.6678822960, +0,
            -0.1883614327, +0.9145869398, +0.3578417250, +0, +0.7625556724, -0.5414408243, -0.3540489801, +0, -0.5870231946, -0.3226498013, -0.7424963803, +0, +0.3051124198, +0.2262544068, -0.9250488391, +0,
            +0.6379576059, +0.5772424240, -0.5097070502, +0, -0.5966775790, +0.1454852398, -0.7891830656, +0, -0.6583305730, +0.6555487542, -0.3699414651, +0, +0.7434892426, +0.2351084581, +0.6260573129, +0,
            +0.5562114096, +0.8264360377, -0.0873632843, +0, -0.3028940016, -0.8251527185, +0.4768419182, +0, +0.1129343818, -0.9858884390, -0.1235710781, +0, +0.5937652891, -0.5896813806, +0.5474656618, +0,
            +0.6757964092, -0.5835758614, -0.4502648413, +0, +0.7242302600, -0.1152719764, +0.6798550586, +0, -0.9511914166, +0.0753623979, -0.2992580792, +0, +0.2539470961, -0.1886339355, +0.9486454084, +0,
            +0.5714336210, -0.1679450851, -0.8032795685, +0, -0.0677823497, +0.3978269256, +0.9149531629, +0, +0.6074972649, +0.7330600240, -0.3058922593, +0, -0.5435478392, +0.1675822484, +0.8224791405, +0,
            -0.5876678086, -0.3380045064, -0.7351186982, +0, -0.7967562400, +0.0409782270, -0.6029098428, +0, -0.1996350917, +0.8706294745, +0.4496111079, +0, -0.0278766033, -0.9106232682, -0.4122962022, +0,
            -0.7797625996, -0.6257634692, +0.0197577558, +0, -0.5211232846, +0.7401644346, -0.4249554471, +0, +0.8575424857, +0.4053272873, -0.3167501783, +0, +0.1045223322, +0.8390195772, -0.5339674439, +0,
            +0.3501822831, +0.9242524096, -0.1520850155, +0, +0.1987849850, +0.0764761326, +0.9770547224, +0, +0.7845996363, +0.6066256811, -0.1280964233, +0, +0.0900673743, -0.9750989929, -0.2026569073, +0,
            -0.8274343547, -0.5422995590, +0.1458203587, +0, -0.3485797732, -0.4158022770, +0.8400003620, +0, -0.2471778936, -0.7304819962, -0.6366310879, +0, -0.3700154943, +0.8577948156, +0.3567584454, +0,
            +0.5913394901, -0.5483119670, -0.5913303597, +0, +0.1204873510, -0.7626472379, -0.6354935001, +0, +0.6169592650, +0.0307964792, +0.7863922953, +0, +0.1258156836, -0.6640829889, -0.7369967419, +0,
            -0.6477565124, -0.1740147258, -0.7417077429, +0, +0.6217889313, -0.7804430448, -0.0654765507, +0, +0.6589943422, -0.6096987708, +0.4404473475, +0, -0.2689837504, -0.6732403169, -0.6887635427, +0,
            -0.3849775103, +0.5676542638, +0.7277093879, +0, +0.5754444400, +0.8110471154, -0.1051963504, +0, +0.9141593684, +0.3832947817, +0.1319005670, +0, -0.1079253190, +0.9245493968, +0.3654593525, +0,
            +0.3779770890, +0.3043148782, +0.8743716458, +0, -0.2142885215, -0.8259286236, +0.5214617324, +0, +0.5802544474, +0.4148098596, -0.7008834116, +0, -0.1982660881, +0.8567161266, -0.4761596756, +0,
            -0.0338155370, +0.3773180787, -0.9254661404, +0, -0.6867922840, -0.6656597827, +0.2919133642, +0, +0.7731742607, -0.2875793547, -0.5652430251, +0, -0.0965594192, +0.9193708367, -0.3813575004, +0,
            +0.2715702457, -0.9577909544, -0.0942660558, +0, +0.2451015704, -0.6917998565, -0.6792188003, +0, +0.9777007820, -0.1753855374, +0.1155036542, +0, -0.5224739938, +0.8521606816, +0.0290361594, +0,
            -0.7734880599, -0.5261292347, +0.3534179531, +0, -0.7134492440, -0.2695472430, +0.6467878011, +0, +0.1644037271, +0.5105846203, -0.8439637196, +0, +0.6494635788, +0.0558561129, +0.7583384168, +0,
            -0.4711970882, +0.5017280509, -0.7254255765, +0, -0.6335764307, -0.2381686273, -0.7361091029, +0, -0.9021533097, -0.2709478030, -0.3357181763, +0, -0.3793711033, +0.8722581170, +0.3086152025, +0,
            -0.6855598966, -0.3250143309, +0.6514394162, +0, +0.2900942210, -0.7799057743, -0.5546100667, +0, -0.2098319339, +0.8503707300, +0.4825351604, +0, -0.4592603758, +0.6598504336, -0.5947077538, +0,
            +0.8715945488, +0.0961636540, -0.4807031248, +0, -0.6776666319, +0.7118504878, -0.1844907016, +0, +0.7044377633, +0.3124275970, +0.6373040360, +0, -0.7052318886, -0.2401093292, -0.6670798253, +0,
            +0.0819210070, -0.7207336136, -0.6883545647, +0, -0.6993680900, -0.5875763221, -0.4069869034, +0, -0.1281454481, +0.6419895885, +0.7559286424, +0, -0.6337388239, -0.6785471501, -0.3714146849, +0,
            +0.5565051903, -0.2168887573, -0.8020356851, +0, -0.5791554484, +0.7244372011, -0.3738578718, +0, +0.1175779076, -0.7096451073, +0.6946792478, +0, -0.6134619607, +0.1323631078, +0.7785527795, +0,
            +0.6984635305, -0.0298051623, -0.7150247190, +0, +0.8318082960, -0.3930171956, +0.3919597455, +0, +0.1469576422, +0.0554165171, -0.9875892167, +0, +0.7088685750, -0.2690503865, +0.6520101478, +0,
            +0.2726053183, +0.6736976600, -0.6868899500, +0, -0.6591295371, +0.3035458599, -0.6880466294, +0, +0.4815131379, -0.7528270071, +0.4487723203, +0, +0.9430009463, +0.1675647412, -0.2875261255, +0,
            +0.4348029570, +0.7695304522, -0.4677277752, +0, +0.3931996180, +0.5944736250, +0.7014236729, +0, +0.7254336655, -0.6039256540, +0.3301814672, +0, +0.7590235227, -0.6506083235, +0.0243331320, +0,
            -0.8552768592, -0.3430042733, +0.3883935666, +0, -0.6139746835, +0.6981725247, +0.3682257648, +0, -0.7465905486, -0.5752009504, +0.3342849376, +0, +0.5730065677, +0.8105555370, -0.1210916791, +0,
            -0.9225877367, -0.3475211012, -0.1675140360, +0, -0.7105816780, -0.4719692027, -0.5218416899, +0, -0.0856460971, +0.3583001386, +0.9296697030, +0, -0.8279697606, -0.2043157126, +0.5222271202, +0,
            +0.4279440230, +0.2781659940, +0.8599346446, +0, +0.5399079671, -0.7857120652, -0.3019204161, +0, +0.5678404253, -0.5495413974, -0.6128307303, +0, -0.9896071041, +0.1365639107, -0.0450341842, +0,
            -0.6154342638, -0.6440875597, +0.4543037336, +0, +0.1074204360, -0.7946340692, +0.5975094525, +0, -0.3595449969, -0.8885529948, +0.2849578400, +0, -0.2180405296, +0.1529888965, +0.9638738118, +0,
            -0.7277432317, -0.6164050508, -0.3007234646, +0, +0.7249729114, -0.0066971948, +0.6887448187, +0, -0.5553659455, -0.5336586252, +0.6377908264, +0, +0.5137558015, +0.7976208196, -0.3160000073, +0,
            -0.3794024848, +0.9245608561, -0.0352275149, +0, +0.8229248650, +0.2745365933, -0.4974176556, +0, -0.5404114394, +0.6091141441, +0.5804613989, +0, +0.8036581901, -0.2703029469, +0.5301601931, +0,
            +0.6044318879, +0.6832968393, +0.4095943388, +0, +0.0638998881, +0.9658208605, -0.2512108074, +0, +0.1087113286, +0.7402471173, -0.6634877936, +0, -0.7134277120, -0.6926784018, +0.1059128479, +0,
            +0.6458897819, -0.5724548511, -0.5050958653, +0, -0.6553931410, +0.7381471625, +0.1599956150, +0, +0.3910961323, +0.9188871375, -0.0518675599, +0, -0.4879022471, -0.5904376907, +0.6429111375, +0,
            +0.6014790094, +0.7707441366, -0.2101820095, +0, -0.5677173047, +0.7511360995, +0.3368851762, +0, +0.7858573506, +0.2266746650, +0.5753666838, +0, -0.4520345543, -0.6042226860, -0.6561857263, +0,
            +0.0022721163, +0.4132844051, -0.9105991643, +0, -0.5815751410, -0.5162925989, +0.6286591339, +0, -0.0370370478, +0.8273785755, +0.5604221175, +0, -0.5119692504, +0.7953543429, -0.3244980058, +0,
            -0.2682417366, -0.9572290247, -0.1084387619, +0, -0.2322482736, -0.9679131102, -0.0959424332, +0, +0.3554328906, -0.8881505545, +0.2913006227, +0, +0.7346520519, -0.4371373164, +0.5188422971, +0,
            +0.9985120116, +0.0465901116, -0.0283394457, +0, -0.3727687490, -0.9082481361, +0.1900757285, +0, +0.9173737700, -0.3483642108, +0.1925298489, +0, +0.2714911074, +0.4147529736, -0.8684886582, +0,
            +0.5131763485, -0.7116334161, +0.4798207128, +0, -0.8737353606, +0.1888699200, -0.4482350644, +0, +0.8460043821, -0.3725217914, +0.3814499973, +0, +0.8978727456, -0.1780209141, -0.4026575304, +0,
            +0.2178065647, -0.9698322841, -0.1094789531, +0, -0.1518031300, -0.7788918132, -0.6085091231, +0, -0.2600384876, -0.4755398075, -0.8403819825, +0, +0.5723135090, -0.7474340931, -0.3373418503, +0,
            -0.7174141009, +0.1699017182, -0.6756111411, +0, -0.6841807840, +0.0214570759, -0.7289967412, +0, -0.2007447902, +0.0655560578, -0.9774476623, +0, -0.1148803697, -0.8044887315, +0.5827524187, +0,
            -0.7870349638, +0.0344748923, +0.6159443543, +0, -0.2015596420, +0.6859872284, +0.6991389226, +0, -0.0858108251, -0.1092083600, -0.9903080513, +0, +0.5532693395, +0.7325250401, -0.3966107710, +0,
            -0.1842489331, -0.9777375055, -0.1004076743, +0, +0.0775473789, -0.9111505856, +0.4047110257, +0, +0.1399838409, +0.7601631212, -0.6344734459, +0, +0.4484419361, -0.8452892480, +0.2904925424, +0
    };
    
    private static double fastMin(double a, double b)
    {
        return Math.min(a, b);
    }
    
    private static double fastMax(double a, double b)
    {
        return Math.max(a, b);
    }
    
    private static double fastAbs(double f)
    {
        return f < 0 ? -f : f;
    }
    
    private static double fastSqrt(double f)
    {
        return Math.sqrt(f);
    }
    
    private static int fastFloor(double f)
    {
        return f >= 0 ? (int) f : (int) f - 1;
    }
    
    private static int fastRound(double f)
    {
        return f >= 0 ? (int) (f + 0.5) : (int) (f - 0.5);
    }
    
    private static double lerp(double a, double b, double t)
    {
        return a + t * (b - a);
    }
    
    private static double hermite(double t)
    {
        return t * t * (3 - 2 * t);
    }
    
    private static double quintic(double t)
    {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    
    private static double lerpCubic(double a, double b, double c, double d, double t)
    {
        double p = (d - c) - (a - b);
        return t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b;
    }
    
    private static double pingPong(double t)
    {
        t -= (int) (t * 0.5) * 2;
        return t < 1 ? t : 2 - t;
    }
    
    private void calculateFractalBounding()
    {
        double gain       = fastAbs(this.mGain);
        double amp        = gain;
        double ampFractal = 1.0;
        for (int i = 1; i < this.mOctaves; i++)
        {
            ampFractal += amp;
            amp *= gain;
        }
        this.mFractalBounding = 1 / ampFractal;
    }
    
    // Hashing
    private static final int PRIME_X = 501125321;
    private static final int PRIME_Y = 1136930381;
    private static final int PRIME_Z = 1720413743;
    
    private static final int    PRIME_MUL = 0x27D4EB2D;
    private static final double VAL_MUL   = 1.0 / 2147483648.0;
    
    private static int hash(int seed, int xPrimed, int yPrimed)
    {
        return (seed ^ xPrimed ^ yPrimed) * FastNoise.PRIME_MUL;
    }
    
    private static int hash(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
        return (seed ^ xPrimed ^ yPrimed ^ zPrimed) * FastNoise.PRIME_MUL;
    }
    
    private static double valCoord(int seed, int xPrimed, int yPrimed)
    {
        int hash = hash(seed, xPrimed, yPrimed);
        hash *= hash;
        return (hash ^ (hash << 19)) * FastNoise.VAL_MUL;
    }
    
    private static double valCoord(int seed, int xPrimed, int yPrimed, int zPrimed)
    {
        int hash = hash(seed, xPrimed, yPrimed, zPrimed);
        hash *= hash;
        return (hash ^ (hash << 19)) * FastNoise.VAL_MUL;
    }
    
    private static double gradCoord(int seed, int xPrimed, int yPrimed, double xd, double yd)
    {
        int hash = hash(seed, xPrimed, yPrimed);
        hash ^= hash >> 15;
        hash &= 0xFE;
        
        double xg = FastNoise.GRAD2[hash];
        double yg = FastNoise.GRAD2[hash | 1];
        
        return xd * xg + yd * yg;
    }
    
    private static double gradCoord(int seed, int xPrimed, int yPrimed, int zPrimed, double xd, double yd, double zd)
    {
        int hash = hash(seed, xPrimed, yPrimed, zPrimed);
        hash ^= hash >> 15;
        hash &= 0xFC;
        
        double xg = FastNoise.GRAD3[hash];
        double yg = FastNoise.GRAD3[hash | 1];
        double zg = FastNoise.GRAD3[hash | 2];
        
        return xd * xg + yd * yg + zd * zg;
    }
    
    // Generic noise gen
    
    private double genNoiseSingle(int seed, double x, double y)
    {
        return switch (this.mNoiseType)
                {
                    case OpenSimplex2 -> singleSimplex(seed, x, y);
                    case OpenSimplex2S -> singleOpenSimplex2S(seed, x, y);
                    case Cellular -> singleCellular(seed, x, y);
                    case Perlin -> singlePerlin(seed, x, y);
                    case ValueCubic -> singleValueCubic(seed, x, y);
                    case Value -> singleValue(seed, x, y);
                };
    }
    
    private double genNoiseSingle(int seed, double x, double y, double z)
    {
        return switch (this.mNoiseType)
                {
                    case OpenSimplex2 -> singleOpenSimplex2(seed, x, y, z);
                    case OpenSimplex2S -> singleOpenSimplex2S(seed, x, y, z);
                    case Cellular -> singleCellular(seed, x, y, z);
                    case Perlin -> singlePerlin(seed, x, y, z);
                    case ValueCubic -> singleValueCubic(seed, x, y, z);
                    case Value -> singleValue(seed, x, y, z);
                };
    }
    
    // Noise Coordinate Transforms (frequency, and possible skew or rotation)
    
    private void updateTransformType3D()
    {
        this.mTransformType3D = switch (this.mRotationType3D)
                {
                    case ImproveXYPlanes -> TransformType3D.ImproveXYPlanes;
                    case ImproveXZPlanes -> TransformType3D.ImproveXZPlanes;
                    default -> switch (this.mNoiseType)
                            {
                                case OpenSimplex2, OpenSimplex2S -> TransformType3D.DefaultOpenSimplex2;
                                default -> TransformType3D.None;
                            };
                };
    }
    
    private void updateWarpTransformType3D()
    {
        this.mWarpTransformType3D = switch (this.mRotationType3D)
                {
                    case ImproveXYPlanes -> TransformType3D.ImproveXYPlanes;
                    case ImproveXZPlanes -> TransformType3D.ImproveXZPlanes;
                    default -> switch (this.mDomainWarpType)
                            {
                                case OpenSimplex2, OpenSimplex2Reduced -> TransformType3D.DefaultOpenSimplex2;
                                default -> TransformType3D.None;
                            };
                };
    }
    
    // Fractal FBm
    
    private double genFractalFBm(double x, double y)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = genNoiseSingle(seed++, x, y);
            sum += noise * amp;
            amp *= lerp(1.0f, fastMin(noise + 1, 2) * 0.5f, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    private double genFractalFBm(double x, double y, double z)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = genNoiseSingle(seed++, x, y, z);
            sum += noise * amp;
            amp *= lerp(1.0f, (noise + 1) * 0.5f, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            z *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    // Fractal Ridged
    
    private double genFractalRidged(double x, double y)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = fastAbs(genNoiseSingle(seed++, x, y));
            sum += (noise * -2 + 1) * amp;
            amp *= lerp(1.0f, 1 - noise, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    private double genFractalRidged(double x, double y, double z)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = fastAbs(genNoiseSingle(seed++, x, y, z));
            sum += (noise * -2 + 1) * amp;
            amp *= lerp(1.0f, 1 - noise, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            z *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    // Fractal PingPong
    
    private double genFractalPingPong(double x, double y)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = pingPong((genNoiseSingle(seed++, x, y) + 1) * this.mPingPongStrength);
            sum += (noise - 0.5f) * 2 * amp;
            amp *= lerp(1.0f, noise, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    private double genFractalPingPong(double x, double y, double z)
    {
        int    seed = this.mSeed;
        double sum  = 0;
        double amp  = this.mFractalBounding;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double noise = pingPong((genNoiseSingle(seed++, x, y, z) + 1) * this.mPingPongStrength);
            sum += (noise - 0.5f) * 2 * amp;
            amp *= lerp(1.0f, noise, this.mWeightedStrength);
            
            x *= this.mLacunarity;
            y *= this.mLacunarity;
            z *= this.mLacunarity;
            amp *= this.mGain;
        }
        
        return sum;
    }
    
    // Simplex/OpenSimplex2 Noise
    
    private double singleSimplex(int seed, double x, double y)
    {
        // 2D OpenSimplex2 case uses the same algorithm as ordinary Simplex.
        
        final double SQRT3 = 1.7320508075688772935274463415059f;
        final double G2    = (3 - SQRT3) / 6;
        
        /*
         * --- Skew moved to switch statements before fractal evaluation ---
         * final FNLfloat F2 = 0.5* (SQRT3 - 1);
         * FNLfloat s = (x + y) * F2;
         * x += s; y += s;
         */
        
        int    i  = fastFloor(x);
        int    j  = fastFloor(y);
        double xi = x - i;
        double yi = y - j;
        
        double t  = (xi + yi) * G2;
        double x0 = xi - t;
        double y0 = yi - t;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        
        double n0, n1, n2;
        
        double a = 0.5 - x0 * x0 - y0 * y0;
        n0 = a <= 0 ? 0 : (a * a) * (a * a) * gradCoord(seed, i, j, x0, y0);
        
        double c = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        n2 = c <= 0 ? 0 : (c * c) * (c * c) * gradCoord(seed, i + PRIME_X, j + PRIME_Y, x0 + (2 * G2 - 1), y0 + (2 * G2 - 1));
        
        if (y0 > x0)
        {
            double x1 = x0 + G2;
            double y1 = y0 + (G2 - 1);
            double b  = 0.5 - x1 * x1 - y1 * y1;
            n1 = b <= 0 ? 0 : (b * b) * (b * b) * gradCoord(seed, i, j + PRIME_Y, x1, y1);
        }
        else
        {
            double x1 = x0 + (G2 - 1);
            double y1 = y0 + G2;
            double b  = 0.5 - x1 * x1 - y1 * y1;
            n1 = b <= 0 ? 0 : (b * b) * (b * b) * gradCoord(seed, i + PRIME_X, j, x1, y1);
        }
        
        return (n0 + n1 + n2) * 99.83685446303647;
    }
    
    private double singleOpenSimplex2(int seed, double x, double y, double z)
    {
        // 3D OpenSimplex2 case uses two offset rotated cube grids.
        
        /*
         * --- Rotation moved to switch statements before fractal evaluation ---
         * final FNLfloat R3 = (FNLfloat)(2.0 / 3.0);
         * FNLfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
         */
        
        int    i  = fastRound(x);
        int    j  = fastRound(y);
        int    k  = fastRound(z);
        double x0 = x - i;
        double y0 = y - j;
        double z0 = z - k;
        
        int xNSign = (int) (-1.0 - x0) | 1;
        int yNSign = (int) (-1.0 - y0) | 1;
        int zNSign = (int) (-1.0 - z0) | 1;
        
        double ax0 = xNSign * -x0;
        double ay0 = yNSign * -y0;
        double az0 = zNSign * -z0;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;
        
        double value = 0;
        double a     = (0.6 - x0 * x0) - (y0 * y0 + z0 * z0);
        
        for (int l = 0; ; l++)
        {
            if (a > 0) value += (a * a) * (a * a) * gradCoord(seed, i, j, k, x0, y0, z0);
            
            if (ax0 >= ay0 && ax0 >= az0)
            {
                double b = a + ax0 + ax0;
                if (b > 1)
                {
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i - xNSign * PRIME_X, j, k, x0 + xNSign, y0, z0);
                }
            }
            else if (ay0 > ax0 && ay0 >= az0)
            {
                double b = a + ay0 + ay0;
                if (b > 1)
                {
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i, j - yNSign * PRIME_Y, k, x0, y0 + yNSign, z0);
                }
            }
            else
            {
                double b = a + az0 + az0;
                if (b > 1)
                {
                    b -= 1;
                    value += (b * b) * (b * b) * gradCoord(seed, i, j, k - zNSign * PRIME_Z, x0, y0, z0 + zNSign);
                }
            }
            
            if (l == 1) break;
            
            ax0 = 0.5 - ax0;
            ay0 = 0.5 - ay0;
            az0 = 0.5 - az0;
            
            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;
            
            a += (0.75 - ax0) - (ay0 + az0);
            
            i += (xNSign >> 1) & PRIME_X;
            j += (yNSign >> 1) & PRIME_Y;
            k += (zNSign >> 1) & PRIME_Z;
            
            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;
            
            seed = ~seed;
        }
        
        return value * 32.69428253173828125;
    }
    
    // OpenSimplex2S Noise
    
    private double singleOpenSimplex2S(int seed, double x, double y)
    {
        // 2D OpenSimplex2S case is a modified 2D simplex noise.
        
        final double SQRT3 = 1.7320508075688772935274463415059;
        final double G2    = (3 - SQRT3) / 6;
        
        /*
         * --- Skew moved to TransformNoiseCoordinate method ---
         * final FNLfloat F2 = 0.5* (SQRT3 - 1);
         * FNLfloat s = (x + y) * F2;
         * x += s; y += s;
         */
        
        int    i  = fastFloor(x);
        int    j  = fastFloor(y);
        double xi = x - i;
        double yi = y - j;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        int i1 = i + PRIME_X;
        int j1 = j + PRIME_Y;
        
        double t  = (xi + yi) * G2;
        double x0 = xi - t;
        double y0 = yi - t;
        
        double a0    = (2.0 / 3.0) - x0 * x0 - y0 * y0;
        double value = (a0 * a0) * (a0 * a0) * gradCoord(seed, i, j, x0, y0);
        
        double a1 = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a0);
        double x1 = x0 - (1 - 2 * G2);
        double y1 = y0 - (1 - 2 * G2);
        value += (a1 * a1) * (a1 * a1) * gradCoord(seed, i1, j1, x1, y1);
        
        // Nested conditionals were faster than compact bit logic/arithmetic.
        double xmyi = xi - yi;
        if (t > G2)
        {
            if (xi + xmyi > 1)
            {
                double x2 = x0 + (3 * G2 - 2);
                double y2 = y0 + (3 * G2 - 1);
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + (PRIME_X << 1), j + PRIME_Y, x2, y2);
            }
            else
            {
                double x2 = x0 + G2;
                double y2 = y0 + (G2 - 1);
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PRIME_Y, x2, y2);
            }
            
            if (yi - xmyi > 1)
            {
                double x3 = x0 + (3 * G2 - 1);
                double y3 = y0 + (3 * G2 - 2);
                double a3 = (2.0 / 3.0) - x3 * x3 - y3 * y3;
                if (a3 > 0) value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + PRIME_X, j + (PRIME_Y << 1), x3, y3);
            }
            else
            {
                double x3 = x0 + (G2 - 1);
                double y3 = y0 + G2;
                double a3 = (2.0 / 3.0) - x3 * x3 - y3 * y3;
                if (a3 > 0) value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + PRIME_X, j, x3, y3);
            }
        }
        else
        {
            if (xi + xmyi < 0)
            {
                double x2 = x0 + (1 - G2);
                double y2 = y0 - G2;
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i - PRIME_X, j, x2, y2);
            }
            else
            {
                double x2 = x0 + (G2 - 1);
                double y2 = y0 + G2;
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + PRIME_X, j, x2, y2);
            }
            
            if (yi < xmyi)
            {
                double x2 = x0 - G2;
                double y2 = y0 - (G2 - 1);
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j - PRIME_Y, x2, y2);
            }
            else
            {
                double x2 = x0 + G2;
                double y2 = y0 + (G2 - 1);
                double a2 = (2.0 / 3.0) - x2 * x2 - y2 * y2;
                if (a2 > 0) value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i, j + PRIME_Y, x2, y2);
            }
        }
        
        return value * 18.24196194486065;
    }
    
    private double singleOpenSimplex2S(int seed, double x, double y, double z)
    {
        // 3D OpenSimplex2S case uses two offset rotated cube grids.
        
        /*
         * --- Rotation moved to TransformNoiseCoordinate method ---
         * final FNLfloat R3 = (FNLfloat)(2.0 / 3.0);
         * FNLfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
         */
        
        int    i  = fastFloor(x);
        int    j  = fastFloor(y);
        int    k  = fastFloor(z);
        double xi = x - i;
        double yi = y - j;
        double zi = z - k;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;
        int seed2 = seed + 1293373;
        
        int xNMask = (int) (-0.5 - xi);
        int yNMask = (int) (-0.5 - yi);
        int zNMask = (int) (-0.5 - zi);
        
        double x0    = xi + xNMask;
        double y0    = yi + yNMask;
        double z0    = zi + zNMask;
        double a0    = 0.75 - x0 * x0 - y0 * y0 - z0 * z0;
        double value = (a0 * a0) * (a0 * a0) * gradCoord(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x0, y0, z0);
        
        double x1 = xi - 0.5;
        double y1 = yi - 0.5;
        double z1 = zi - 0.5;
        double a1 = 0.75 - x1 * x1 - y1 * y1 - z1 * z1;
        value += (a1 * a1) * (a1 * a1) * gradCoord(seed2, i + PRIME_X, j + PRIME_Y, k + PRIME_Z, x1, y1, z1);
        
        double xAFlipMask0 = ((xNMask | 1) << 1) * x1;
        double yAFlipMask0 = ((yNMask | 1) << 1) * y1;
        double zAFlipMask0 = ((zNMask | 1) << 1) * z1;
        double xAFlipMask1 = (-2 - (xNMask << 2)) * x1 - 1.0;
        double yAFlipMask1 = (-2 - (yNMask << 2)) * y1 - 1.0;
        double zAFlipMask1 = (-2 - (zNMask << 2)) * z1 - 1.0;
        
        boolean skip5 = false;
        double  a2    = xAFlipMask0 + a0;
        if (a2 > 0)
        {
            double x2 = x0 - (xNMask | 1);
            double y2 = y0;
            double z2 = z0;
            value += (a2 * a2) * (a2 * a2) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x2, y2, z2);
        }
        else
        {
            double a3 = yAFlipMask0 + zAFlipMask0 + a0;
            if (a3 > 0)
            {
                double x3 = x0;
                double y3 = y0 - (yNMask | 1);
                double z3 = z0 - (zNMask | 1);
                value += (a3 * a3) * (a3 * a3) * gradCoord(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x3, y3, z3);
            }
            
            double a4 = xAFlipMask1 + a1;
            if (a4 > 0)
            {
                double x4 = (xNMask | 1) + x1;
                double y4 = y1;
                double z4 = z1;
                value += (a4 * a4) * (a4 * a4) * gradCoord(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + PRIME_Z, x4, y4, z4);
                skip5 = true;
            }
        }
        
        boolean skip9 = false;
        double  a6    = yAFlipMask0 + a0;
        if (a6 > 0)
        {
            double x6 = x0;
            double y6 = y0 - (yNMask | 1);
            double z6 = z0;
            value += (a6 * a6) * (a6 * a6) * gradCoord(seed, i + (xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), x6, y6, z6);
        }
        else
        {
            double a7 = xAFlipMask0 + zAFlipMask0 + a0;
            if (a7 > 0)
            {
                double x7 = x0 - (xNMask | 1);
                double y7 = y0;
                double z7 = z0 - (zNMask | 1);
                value += (a7 * a7) * (a7 * a7) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), x7, y7, z7);
            }
            
            double a8 = yAFlipMask1 + a1;
            if (a8 > 0)
            {
                double x8 = x1;
                double y8 = (yNMask | 1) + y1;
                double z8 = z1;
                value += (a8 * a8) * (a8 * a8) * gradCoord(seed2, i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, x8, y8, z8);
                skip9 = true;
            }
        }
        
        boolean skipD = false;
        double  aA    = zAFlipMask0 + a0;
        if (aA > 0)
        {
            double xA = x0;
            double yA = y0;
            double zA = z0 - (zNMask | 1);
            value += (aA * aA) * (aA * aA) * gradCoord(seed, i + (xNMask & PRIME_X), j + (yNMask & PRIME_Y), k + (~zNMask & PRIME_Z), xA, yA, zA);
        }
        else
        {
            double aB = xAFlipMask0 + yAFlipMask0 + a0;
            if (aB > 0)
            {
                double xB = x0 - (xNMask | 1);
                double yB = y0 - (yNMask | 1);
                double zB = z0;
                value += (aB * aB) * (aB * aB) * gradCoord(seed, i + (~xNMask & PRIME_X), j + (~yNMask & PRIME_Y), k + (zNMask & PRIME_Z), xB, yB, zB);
            }
            
            double aC = zAFlipMask1 + a1;
            if (aC > 0)
            {
                double xC = x1;
                double yC = y1;
                double zC = (zNMask | 1) + z1;
                value += (aC * aC) * (aC * aC) * gradCoord(seed2, i + PRIME_X, j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), xC, yC, zC);
                skipD = true;
            }
        }
        
        if (!skip5)
        {
            double a5 = yAFlipMask1 + zAFlipMask1 + a1;
            if (a5 > 0)
            {
                double x5 = x1;
                double y5 = (yNMask | 1) + y1;
                double z5 = (zNMask | 1) + z1;
                value += (a5 * a5) * (a5 * a5) * gradCoord(seed2, i + PRIME_X, j + (yNMask & (PRIME_Y << 1)), k + (zNMask & (PRIME_Z << 1)), x5, y5, z5);
            }
        }
        
        if (!skip9)
        {
            double a9 = xAFlipMask1 + zAFlipMask1 + a1;
            if (a9 > 0)
            {
                double x9 = (xNMask | 1) + x1;
                double y9 = y1;
                double z9 = (zNMask | 1) + z1;
                value += (a9 * a9) * (a9 * a9) * gradCoord(seed2, i + (xNMask & (PRIME_X * 2)), j + PRIME_Y, k + (zNMask & (PRIME_Z << 1)), x9, y9, z9);
            }
        }
        
        if (!skipD)
        {
            double aD = xAFlipMask1 + yAFlipMask1 + a1;
            if (aD > 0)
            {
                double xD = (xNMask | 1) + x1;
                double yD = (yNMask | 1) + y1;
                double zD = z1;
                value += (aD * aD) * (aD * aD) * gradCoord(seed2, i + (xNMask & (PRIME_X << 1)), j + (yNMask & (PRIME_Y << 1)), k + PRIME_Z, xD, yD, zD);
            }
        }
        
        return value * 9.046026385208288;
    }
    
    // Cellular Noise
    
    private double singleCellular(int seed, double x, double y)
    {
        int xr = fastRound(x);
        int yr = fastRound(y);
        
        double distance0   = Double.MAX_VALUE;
        double distance1   = Double.MAX_VALUE;
        int    closestHash = 0;
        
        double cellularJitter = 0.43701595 * this.mCellularJitterModifier;
        
        int xPrimed     = (xr - 1) * PRIME_X;
        int yPrimedBase = (yr - 1) * PRIME_Y;
        
        switch (this.mCellularDistanceFunction)
        {
            case Euclidean, EuclideanSq -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int hash = hash(seed, xPrimed, yPrimed);
                        int idx  = hash & (255 << 1);
                        
                        double vecX = (xi - x) + VEC2[idx] * cellularJitter;
                        double vecY = (yi - y) + VEC2[idx | 1] * cellularJitter;
                        
                        double newDistance = vecX * vecX + vecY * vecY;
                        
                        distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0   = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
            case Manhattan -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int hash = hash(seed, xPrimed, yPrimed);
                        int idx  = hash & (255 << 1);
                        
                        double vecX = (xi - x) + VEC2[idx] * cellularJitter;
                        double vecY = (yi - y) + VEC2[idx | 1] * cellularJitter;
                        
                        double newDistance = fastAbs(vecX) + fastAbs(vecY);
                        
                        distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0   = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
            case Hybrid -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int hash = hash(seed, xPrimed, yPrimed);
                        int idx  = hash & (255 << 1);
                        
                        double vecX = (xi - x) + VEC2[idx] * cellularJitter;
                        double vecY = (yi - y) + VEC2[idx | 1] * cellularJitter;
                        
                        double newDistance = (fastAbs(vecX) + fastAbs(vecY)) + (vecX * vecX + vecY * vecY);
                        
                        distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                        if (newDistance < distance0)
                        {
                            distance0   = newDistance;
                            closestHash = hash;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
        }
        
        if (this.mCellularDistanceFunction == CellularDistanceFunction.Euclidean && this.mCellularReturnType != CellularReturnType.CellValue)
        {
            distance0 = fastSqrt(distance0);
            distance1 = fastSqrt(distance1);
        }
        
        return switch (this.mCellularReturnType)
                {
                    case CellValue -> closestHash * (1 / 2147483648.0);
                    case Distance -> distance0 - 1;
                    case Distance2 -> distance1 - 1;
                    case Distance2Add -> (distance1 + distance0) * 0.5 - 1;
                    case Distance2Sub -> distance1 - distance0 - 1;
                    case Distance2Mul -> distance1 * distance0 * 0.5 - 1;
                    case Distance2Div -> distance0 / distance1 - 1;
                };
    }
    
    private double singleCellular(int seed, double x, double y, double z)
    {
        int xr = fastRound(x);
        int yr = fastRound(y);
        int zr = fastRound(z);
        
        double distance0   = Double.MAX_VALUE;
        double distance1   = Double.MAX_VALUE;
        int    closestHash = 0;
        
        double cellularJitter = 0.39614353 * this.mCellularJitterModifier;
        
        int xPrimed     = (xr - 1) * PRIME_X;
        int yPrimedBase = (yr - 1) * PRIME_Y;
        int zPrimedBase = (zr - 1) * PRIME_Z;
        
        switch (this.mCellularDistanceFunction)
        {
            case Euclidean, EuclideanSq -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int zPrimed = zPrimedBase;
                        
                        for (int zi = zr - 1; zi <= zr + 1; zi++)
                        {
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx  = hash & (255 << 2);
                            
                            double vecX = (xi - x) + VEC3[idx] * cellularJitter;
                            double vecY = (yi - y) + VEC3[idx | 1] * cellularJitter;
                            double vecZ = (zi - z) + VEC3[idx | 2] * cellularJitter;
                            
                            double newDistance = vecX * vecX + vecY * vecY + vecZ * vecZ;
                            
                            distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0   = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
            case Manhattan -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int zPrimed = zPrimedBase;
                        
                        for (int zi = zr - 1; zi <= zr + 1; zi++)
                        {
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx  = hash & (255 << 2);
                            
                            double vecX = (xi - x) + VEC3[idx] * cellularJitter;
                            double vecY = (yi - y) + VEC3[idx | 1] * cellularJitter;
                            double vecZ = (zi - z) + VEC3[idx | 2] * cellularJitter;
                            
                            double newDistance = fastAbs(vecX) + fastAbs(vecY) + fastAbs(vecZ);
                            
                            distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0   = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
            case Hybrid -> {
                for (int xi = xr - 1; xi <= xr + 1; xi++)
                {
                    int yPrimed = yPrimedBase;
                    
                    for (int yi = yr - 1; yi <= yr + 1; yi++)
                    {
                        int zPrimed = zPrimedBase;
                        
                        for (int zi = zr - 1; zi <= zr + 1; zi++)
                        {
                            int hash = hash(seed, xPrimed, yPrimed, zPrimed);
                            int idx  = hash & (255 << 2);
                            
                            double vecX = (xi - x) + VEC3[idx] * cellularJitter;
                            double vecY = (yi - y) + VEC3[idx | 1] * cellularJitter;
                            double vecZ = (zi - z) + VEC3[idx | 2] * cellularJitter;
                            
                            double newDistance = (fastAbs(vecX) + fastAbs(vecY) + fastAbs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ);
                            
                            distance1 = fastMax(fastMin(distance1, newDistance), distance0);
                            if (newDistance < distance0)
                            {
                                distance0   = newDistance;
                                closestHash = hash;
                            }
                            zPrimed += PRIME_Z;
                        }
                        yPrimed += PRIME_Y;
                    }
                    xPrimed += PRIME_X;
                }
            }
        }
        
        if (this.mCellularDistanceFunction == CellularDistanceFunction.Euclidean && this.mCellularReturnType != CellularReturnType.CellValue)
        {
            distance0 = fastSqrt(distance0);
            distance1 = fastSqrt(distance1);
        }
        
        return switch (this.mCellularReturnType)
                {
                    case CellValue -> closestHash * (1 / 2147483648.0);
                    case Distance -> distance0 - 1;
                    case Distance2 -> distance1 - 1;
                    case Distance2Add -> (distance1 + distance0) * 0.5 - 1;
                    case Distance2Sub -> distance1 - distance0 - 1;
                    case Distance2Mul -> distance1 * distance0 * 0.5 - 1;
                    case Distance2Div -> distance0 / distance1 - 1;
                };
    }
    
    // Perlin Noise
    
    private double singlePerlin(int seed, double x, double y)
    {
        int x0 = fastFloor(x);
        int y0 = fastFloor(y);
        
        double xd0 = x - x0;
        double yd0 = y - y0;
        double xd1 = xd0 - 1;
        double yd1 = yd0 - 1;
        
        double xs = quintic(xd0);
        double ys = quintic(yd0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        
        double xf0 = lerp(gradCoord(seed, x0, y0, xd0, yd0), gradCoord(seed, x1, y0, xd1, yd0), xs);
        double xf1 = lerp(gradCoord(seed, x0, y1, xd0, yd1), gradCoord(seed, x1, y1, xd1, yd1), xs);
        
        return lerp(xf0, xf1, ys) * 1.4247691104677813;
    }
    
    private double singlePerlin(int seed, double x, double y, double z)
    {
        int x0 = fastFloor(x);
        int y0 = fastFloor(y);
        int z0 = fastFloor(z);
        
        double xd0 = x - x0;
        double yd0 = y - y0;
        double zd0 = z - z0;
        double xd1 = xd0 - 1;
        double yd1 = yd0 - 1;
        double zd1 = zd0 - 1;
        
        double xs = quintic(xd0);
        double ys = quintic(yd0);
        double zs = quintic(zd0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        int z1 = z0 + PRIME_Z;
        
        double xf00 = lerp(gradCoord(seed, x0, y0, z0, xd0, yd0, zd0), gradCoord(seed, x1, y0, z0, xd1, yd0, zd0), xs);
        double xf10 = lerp(gradCoord(seed, x0, y1, z0, xd0, yd1, zd0), gradCoord(seed, x1, y1, z0, xd1, yd1, zd0), xs);
        double xf01 = lerp(gradCoord(seed, x0, y0, z1, xd0, yd0, zd1), gradCoord(seed, x1, y0, z1, xd1, yd0, zd1), xs);
        double xf11 = lerp(gradCoord(seed, x0, y1, z1, xd0, yd1, zd1), gradCoord(seed, x1, y1, z1, xd1, yd1, zd1), xs);
        
        double yf0 = lerp(xf00, xf10, ys);
        double yf1 = lerp(xf01, xf11, ys);
        
        return lerp(yf0, yf1, zs) * 0.964921414852142333984375;
    }
    
    // Value Cubic Noise
    
    private double singleValueCubic(int seed, double x, double y)
    {
        int x1 = fastFloor(x);
        int y1 = fastFloor(y);
        
        double xs = x - x1;
        double ys = y - y1;
        
        x1 *= PRIME_X;
        y1 *= PRIME_Y;
        int x0 = x1 - PRIME_X;
        int y0 = y1 - PRIME_Y;
        int x2 = x1 + PRIME_X;
        int y2 = y1 + PRIME_Y;
        int x3 = x1 + (PRIME_X << 1);
        int y3 = y1 + (PRIME_Y << 1);
        
        return lerpCubic(
                lerpCubic(valCoord(seed, x0, y0), valCoord(seed, x1, y0), valCoord(seed, x2, y0), valCoord(seed, x3, y0), xs),
                lerpCubic(valCoord(seed, x0, y1), valCoord(seed, x1, y1), valCoord(seed, x2, y1), valCoord(seed, x3, y1), xs),
                lerpCubic(valCoord(seed, x0, y2), valCoord(seed, x1, y2), valCoord(seed, x2, y2), valCoord(seed, x3, y2), xs),
                lerpCubic(valCoord(seed, x0, y3), valCoord(seed, x1, y3), valCoord(seed, x2, y3), valCoord(seed, x3, y3), xs),
                ys) * (1 / (1.5 * 1.5));
    }
    
    private double singleValueCubic(int seed, double x, double y, double z)
    {
        int x1 = fastFloor(x);
        int y1 = fastFloor(y);
        int z1 = fastFloor(z);
        
        double xs = x - x1;
        double ys = y - y1;
        double zs = z - z1;
        
        x1 *= PRIME_X;
        y1 *= PRIME_Y;
        z1 *= PRIME_Z;
        
        int x0 = x1 - PRIME_X;
        int y0 = y1 - PRIME_Y;
        int z0 = z1 - PRIME_Z;
        int x2 = x1 + PRIME_X;
        int y2 = y1 + PRIME_Y;
        int z2 = z1 + PRIME_Z;
        int x3 = x1 + (PRIME_X << 1);
        int y3 = y1 + (PRIME_Y << 1);
        int z3 = z1 + (PRIME_Z << 1);
        
        
        return lerpCubic(
                lerpCubic(
                        lerpCubic(valCoord(seed, x0, y0, z0), valCoord(seed, x1, y0, z0), valCoord(seed, x2, y0, z0), valCoord(seed, x3, y0, z0), xs),
                        lerpCubic(valCoord(seed, x0, y1, z0), valCoord(seed, x1, y1, z0), valCoord(seed, x2, y1, z0), valCoord(seed, x3, y1, z0), xs),
                        lerpCubic(valCoord(seed, x0, y2, z0), valCoord(seed, x1, y2, z0), valCoord(seed, x2, y2, z0), valCoord(seed, x3, y2, z0), xs),
                        lerpCubic(valCoord(seed, x0, y3, z0), valCoord(seed, x1, y3, z0), valCoord(seed, x2, y3, z0), valCoord(seed, x3, y3, z0), xs),
                        ys),
                lerpCubic(
                        lerpCubic(valCoord(seed, x0, y0, z1), valCoord(seed, x1, y0, z1), valCoord(seed, x2, y0, z1), valCoord(seed, x3, y0, z1), xs),
                        lerpCubic(valCoord(seed, x0, y1, z1), valCoord(seed, x1, y1, z1), valCoord(seed, x2, y1, z1), valCoord(seed, x3, y1, z1), xs),
                        lerpCubic(valCoord(seed, x0, y2, z1), valCoord(seed, x1, y2, z1), valCoord(seed, x2, y2, z1), valCoord(seed, x3, y2, z1), xs),
                        lerpCubic(valCoord(seed, x0, y3, z1), valCoord(seed, x1, y3, z1), valCoord(seed, x2, y3, z1), valCoord(seed, x3, y3, z1), xs),
                        ys),
                lerpCubic(
                        lerpCubic(valCoord(seed, x0, y0, z2), valCoord(seed, x1, y0, z2), valCoord(seed, x2, y0, z2), valCoord(seed, x3, y0, z2), xs),
                        lerpCubic(valCoord(seed, x0, y1, z2), valCoord(seed, x1, y1, z2), valCoord(seed, x2, y1, z2), valCoord(seed, x3, y1, z2), xs),
                        lerpCubic(valCoord(seed, x0, y2, z2), valCoord(seed, x1, y2, z2), valCoord(seed, x2, y2, z2), valCoord(seed, x3, y2, z2), xs),
                        lerpCubic(valCoord(seed, x0, y3, z2), valCoord(seed, x1, y3, z2), valCoord(seed, x2, y3, z2), valCoord(seed, x3, y3, z2), xs),
                        ys),
                lerpCubic(
                        lerpCubic(valCoord(seed, x0, y0, z3), valCoord(seed, x1, y0, z3), valCoord(seed, x2, y0, z3), valCoord(seed, x3, y0, z3), xs),
                        lerpCubic(valCoord(seed, x0, y1, z3), valCoord(seed, x1, y1, z3), valCoord(seed, x2, y1, z3), valCoord(seed, x3, y1, z3), xs),
                        lerpCubic(valCoord(seed, x0, y2, z3), valCoord(seed, x1, y2, z3), valCoord(seed, x2, y2, z3), valCoord(seed, x3, y2, z3), xs),
                        lerpCubic(valCoord(seed, x0, y3, z3), valCoord(seed, x1, y3, z3), valCoord(seed, x2, y3, z3), valCoord(seed, x3, y3, z3), xs),
                        ys),
                zs) * (1 / (1.5 * 1.5 * 1.5));
    }
    
    // Value Noise
    
    private double singleValue(int seed, double x, double y)
    {
        int x0 = fastFloor(x);
        int y0 = fastFloor(y);
        
        double xs = hermite(x - x0);
        double ys = hermite(y - y0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        
        return lerp(
                lerp(valCoord(seed, x0, y0), valCoord(seed, x1, y0), xs),
                lerp(valCoord(seed, x0, y1), valCoord(seed, x1, y1), xs),
                ys);
    }
    
    private double singleValue(int seed, double x, double y, double z)
    {
        int x0 = fastFloor(x);
        int y0 = fastFloor(y);
        int z0 = fastFloor(z);
        
        double xs = hermite(x - x0);
        double ys = hermite(y - y0);
        double zs = hermite(z - z0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        int z1 = z0 + PRIME_Z;
        
        return lerp(
                lerp(
                        lerp(valCoord(seed, x0, y0, z0), valCoord(seed, x1, y0, z0), xs),
                        lerp(valCoord(seed, x0, y1, z0), valCoord(seed, x1, y1, z0), xs),
                        ys),
                lerp(
                        lerp(valCoord(seed, x0, y0, z1), valCoord(seed, x1, y0, z1), xs),
                        lerp(valCoord(seed, x0, y1, z1), valCoord(seed, x1, y1, z1), xs),
                        ys),
                zs);
    }
    
    // Domain Warp
    
    private void doSingleDomainWarp(int seed, double amp, double freq, double x, double y, Vector2 coord)
    {
        switch (this.mDomainWarpType)
        {
            case OpenSimplex2 -> singleDomainWarpSimplexGradient(seed, amp * 38.283687591552734375, freq, x, y, coord, false);
            case OpenSimplex2Reduced -> singleDomainWarpSimplexGradient(seed, amp * 16.0, freq, x, y, coord, true);
            case BasicGrid -> singleDomainWarpBasicGrid(seed, amp, freq, x, y, coord);
        }
    }
    
    private void doSingleDomainWarp(int seed, double amp, double freq, double x, double y, double z, Vector3 coord)
    {
        switch (this.mDomainWarpType)
        {
            case OpenSimplex2 -> singleDomainWarpOpenSimplex2Gradient(seed, amp * 32.69428253173828125, freq, x, y, z, coord, false);
            case OpenSimplex2Reduced -> singleDomainWarpOpenSimplex2Gradient(seed, amp * 7.71604938271605, freq, x, y, z, coord, true);
            case BasicGrid -> singleDomainWarpBasicGrid(seed, amp, freq, x, y, z, coord);
        }
    }
    
    // Domain Warp Single Wrapper
    
    private void domainWarpSingle(Vector2 coord)
    {
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        double xs = coord.x;
        double ys = coord.y;
        switch (this.mDomainWarpType)
        {
            case OpenSimplex2, OpenSimplex2Reduced -> {
                final double SQRT3 = 1.7320508075688772935274463415059;
                final double F2    = 0.5 * (SQRT3 - 1);
                double t = (xs + ys) * F2;
                xs += t;
                ys += t;
            }
        }
        
        doSingleDomainWarp(seed, amp, freq, xs, ys, coord);
    }
    
    private void domainWarpSingle(Vector3 coord)
    {
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        double xs = coord.x;
        double ys = coord.y;
        double zs = coord.z;
        switch (this.mWarpTransformType3D)
        {
            case ImproveXYPlanes -> {
                double xy = xs + ys;
                double s2 = xy * -(double) 0.211324865405187;
                zs *= 0.577350269189626;
                xs += s2 - zs;
                ys = ys + s2 - zs;
                zs += xy * 0.577350269189626;
            }
            case ImproveXZPlanes -> {
                double xz = xs + zs;
                double s2 = xz * -(double) 0.211324865405187;
                ys *= 0.577350269189626;
                xs += s2 - ys;
                zs += s2 - ys;
                ys += xz * 0.577350269189626;
            }
            case DefaultOpenSimplex2 -> {
                final double R3 = 2.0 / 3.0;
                double r = (xs + ys + zs) * R3; // Rotation, not skew
                xs = r - xs;
                ys = r - ys;
                zs = r - zs;
            }
        }
        
        doSingleDomainWarp(seed, amp, freq, xs, ys, zs, coord);
    }
    
    // Domain Warp Fractal Progressive
    
    private void domainWarpFractalProgressive(Vector2 coord)
    {
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double xs = coord.x;
            double ys = coord.y;
            switch (this.mDomainWarpType)
            {
                case OpenSimplex2, OpenSimplex2Reduced -> {
                    final double SQRT3 = 1.7320508075688772935274463415059;
                    final double F2    = 0.5 * (SQRT3 - 1);
                    double t = (xs + ys) * F2;
                    xs += t;
                    ys += t;
                }
            }
            
            doSingleDomainWarp(seed, amp, freq, xs, ys, coord);
            
            seed++;
            amp *= this.mGain;
            freq *= this.mLacunarity;
        }
    }
    
    private void domainWarpFractalProgressive(Vector3 coord)
    {
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            double xs = coord.x;
            double ys = coord.y;
            double zs = coord.z;
            switch (this.mWarpTransformType3D)
            {
                case ImproveXYPlanes -> {
                    double xy = xs + ys;
                    double s2 = xy * -(double) 0.211324865405187;
                    zs *= 0.577350269189626;
                    xs += s2 - zs;
                    ys = ys + s2 - zs;
                    zs += xy * 0.577350269189626;
                }
                case ImproveXZPlanes -> {
                    double xz = xs + zs;
                    double s2 = xz * -(double) 0.211324865405187;
                    ys *= 0.577350269189626;
                    xs += s2 - ys;
                    zs += s2 - ys;
                    ys += xz * 0.577350269189626;
                }
                case DefaultOpenSimplex2 -> {
                    final double R3 = 2.0 / 3.0;
                    double r = (xs + ys + zs) * R3; // Rotation, not skew
                    xs = r - xs;
                    ys = r - ys;
                    zs = r - zs;
                }
            }
            
            doSingleDomainWarp(seed, amp, freq, xs, ys, zs, coord);
            
            seed++;
            amp *= this.mGain;
            freq *= this.mLacunarity;
        }
    }
    
    // Domain Warp Fractal Independent
    private void domainWarpFractalIndependent(Vector2 coord)
    {
        double xs = coord.x;
        double ys = coord.y;
        switch (this.mDomainWarpType)
        {
            case OpenSimplex2, OpenSimplex2Reduced -> {
                final double SQRT3 = 1.7320508075688772935274463415059;
                final double F2    = 0.5 * (SQRT3 - 1);
                double t = (xs + ys) * F2;
                xs += t;
                ys += t;
            }
        }
        
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            doSingleDomainWarp(seed, amp, freq, xs, ys, coord);
            
            seed++;
            amp *= this.mGain;
            freq *= this.mLacunarity;
        }
    }
    
    private void domainWarpFractalIndependent(Vector3 coord)
    {
        double xs = coord.x;
        double ys = coord.y;
        double zs = coord.z;
        switch (this.mWarpTransformType3D)
        {
            case ImproveXYPlanes -> {
                double xy = xs + ys;
                double s2 = xy * -(double) 0.211324865405187;
                zs *= 0.577350269189626;
                xs += s2 - zs;
                ys = ys + s2 - zs;
                zs += xy * 0.577350269189626;
            }
            case ImproveXZPlanes -> {
                double xz = xs + zs;
                double s2 = xz * -(double) 0.211324865405187;
                ys *= 0.577350269189626;
                xs += s2 - ys;
                zs += s2 - ys;
                ys += xz * 0.577350269189626;
            }
            case DefaultOpenSimplex2 -> {
                final double R3 = 2.0 / 3.0;
                double r = (xs + ys + zs) * R3; // Rotation, not skew
                xs = r - xs;
                ys = r - ys;
                zs = r - zs;
            }
        }
        
        int    seed = this.mSeed;
        double amp  = this.mDomainWarpAmp * this.mFractalBounding;
        double freq = this.mFrequency;
        
        for (int i = 0; i < this.mOctaves; i++)
        {
            doSingleDomainWarp(seed, amp, freq, xs, ys, zs, coord);
            
            seed++;
            amp *= this.mGain;
            freq *= this.mLacunarity;
        }
    }
    
    // Domain Warp Basic Grid
    
    private void singleDomainWarpBasicGrid(int seed, double warpAmp, double frequency, double x, double y, Vector2 coord)
    {
        double xf = x * frequency;
        double yf = y * frequency;
        
        int x0 = fastFloor(xf);
        int y0 = fastFloor(yf);
        
        double xs = hermite(xf - x0);
        double ys = hermite(yf - y0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        
        int hash0 = hash(seed, x0, y0) & (255 << 1);
        int hash1 = hash(seed, x1, y0) & (255 << 1);
        
        double lx0x = lerp(VEC2[hash0], VEC2[hash1], xs);
        double ly0x = lerp(VEC2[hash0 | 1], VEC2[hash1 | 1], xs);
        
        hash0 = hash(seed, x0, y1) & (255 << 1);
        hash1 = hash(seed, x1, y1) & (255 << 1);
        
        double lx1x = lerp(VEC2[hash0], VEC2[hash1], xs);
        double ly1x = lerp(VEC2[hash0 | 1], VEC2[hash1 | 1], xs);
        
        coord.x += lerp(lx0x, lx1x, ys) * warpAmp;
        coord.y += lerp(ly0x, ly1x, ys) * warpAmp;
    }
    
    private void singleDomainWarpBasicGrid(int seed, double warpAmp, double frequency, double x, double y, double z, Vector3 coord)
    {
        double xf = x * frequency;
        double yf = y * frequency;
        double zf = z * frequency;
        
        int x0 = fastFloor(xf);
        int y0 = fastFloor(yf);
        int z0 = fastFloor(zf);
        
        double xs = hermite(xf - x0);
        double ys = hermite(yf - y0);
        double zs = hermite(zf - z0);
        
        x0 *= PRIME_X;
        y0 *= PRIME_Y;
        z0 *= PRIME_Z;
        int x1 = x0 + PRIME_X;
        int y1 = y0 + PRIME_Y;
        int z1 = z0 + PRIME_Z;
        
        int hash0 = hash(seed, x0, y0, z0) & (255 << 2);
        int hash1 = hash(seed, x1, y0, z0) & (255 << 2);
        
        double lx0x = lerp(VEC3[hash0], VEC3[hash1], xs);
        double ly0x = lerp(VEC3[hash0 | 1], VEC3[hash1 | 1], xs);
        double lz0x = lerp(VEC3[hash0 | 2], VEC3[hash1 | 2], xs);
        
        hash0 = hash(seed, x0, y1, z0) & (255 << 2);
        hash1 = hash(seed, x1, y1, z0) & (255 << 2);
        
        double lx1x = lerp(VEC3[hash0], VEC3[hash1], xs);
        double ly1x = lerp(VEC3[hash0 | 1], VEC3[hash1 | 1], xs);
        double lz1x = lerp(VEC3[hash0 | 2], VEC3[hash1 | 2], xs);
        
        double lx0y = lerp(lx0x, lx1x, ys);
        double ly0y = lerp(ly0x, ly1x, ys);
        double lz0y = lerp(lz0x, lz1x, ys);
        
        hash0 = hash(seed, x0, y0, z1) & (255 << 2);
        hash1 = hash(seed, x1, y0, z1) & (255 << 2);
        
        lx0x = lerp(VEC3[hash0], VEC3[hash1], xs);
        ly0x = lerp(VEC3[hash0 | 1], VEC3[hash1 | 1], xs);
        lz0x = lerp(VEC3[hash0 | 2], VEC3[hash1 | 2], xs);
        
        hash0 = hash(seed, x0, y1, z1) & (255 << 2);
        hash1 = hash(seed, x1, y1, z1) & (255 << 2);
        
        lx1x = lerp(VEC3[hash0], VEC3[hash1], xs);
        ly1x = lerp(VEC3[hash0 | 1], VEC3[hash1 | 1], xs);
        lz1x = lerp(VEC3[hash0 | 2], VEC3[hash1 | 2], xs);
        
        coord.x += lerp(lx0y, lerp(lx0x, lx1x, ys), zs) * warpAmp;
        coord.y += lerp(ly0y, lerp(ly0x, ly1x, ys), zs) * warpAmp;
        coord.z += lerp(lz0y, lerp(lz0x, lz1x, ys), zs) * warpAmp;
    }
    
    // Domain Warp Simplex/OpenSimplex2
    private void singleDomainWarpSimplexGradient(int seed, double warpAmp, double frequency, double x, double y, Vector2 coord, boolean outGradOnly)
    {
        final double SQRT3 = 1.7320508075688772935274463415059;
        final double G2    = (3 - SQRT3) / 6;
        
        x *= frequency;
        y *= frequency;
        
        /*
         * --- Skew moved to switch statements before fractal evaluation  ---
         * final FNLfloat F2 = 0.5 * (SQRT3 - 1);
         * FNLfloat s = (x + y) * F2;
         * x += s; y += s;
         */
        
        int    i  = fastFloor(x);
        int    j  = fastFloor(y);
        double xi = x - i;
        double yi = y - j;
        
        double t  = (xi + yi) * G2;
        double x0 = xi - t;
        double y0 = yi - t;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        
        double vx, vy;
        vx = vy = 0;
        
        double a = 0.5 - x0 * x0 - y0 * y0;
        if (a > 0)
        {
            double aaaa = (a * a) * (a * a);
            double xo, yo;
            if (outGradOnly)
            {
                int hash = hash(seed, i, j) & (255 << 1);
                xo = VEC2[hash];
                yo = VEC2[hash | 1];
            }
            else
            {
                int    hash   = hash(seed, i, j);
                int    index1 = hash & (127 << 1);
                int    index2 = (hash >> 7) & (255 << 1);
                double xg     = GRAD2[index1];
                double yg     = GRAD2[index1 | 1];
                double value  = x0 * xg + y0 * yg;
                double xgo    = VEC2[index2];
                double ygo    = VEC2[index2 | 1];
                xo = value * xgo;
                yo = value * ygo;
            }
            vx += aaaa * xo;
            vy += aaaa * yo;
        }
        
        double c = 2 * (1 - 2 * G2) * (1 / G2 - 2) * t + ((-2 * (1 - 2 * G2) * (1 - 2 * G2)) + a);
        if (c > 0)
        {
            double x2   = x0 + (2 * G2 - 1);
            double y2   = y0 + (2 * G2 - 1);
            double cccc = (c * c) * (c * c);
            double xo, yo;
            if (outGradOnly)
            {
                int hash = hash(seed, i + PRIME_X, j + PRIME_Y) & (255 << 1);
                xo = VEC2[hash];
                yo = VEC2[hash | 1];
            }
            else
            {
                int    hash   = hash(seed, i + PRIME_X, j + PRIME_Y);
                int    index1 = hash & (127 << 1);
                int    index2 = (hash >> 7) & (255 << 1);
                double xg     = GRAD2[index1];
                double yg     = GRAD2[index1 | 1];
                double value  = x2 * xg + y2 * yg;
                double xgo    = VEC2[index2];
                double ygo    = VEC2[index2 | 1];
                xo = value * xgo;
                yo = value * ygo;
            }
            vx += cccc * xo;
            vy += cccc * yo;
        }
        
        if (y0 > x0)
        {
            double x1 = x0 + G2;
            double y1 = y0 + (G2 - 1);
            double b  = 0.5 - x1 * x1 - y1 * y1;
            if (b > 0)
            {
                double bbbb = (b * b) * (b * b);
                double xo, yo;
                if (outGradOnly)
                {
                    int hash = hash(seed, i, j + PRIME_Y) & (255 << 1);
                    xo = VEC2[hash];
                    yo = VEC2[hash | 1];
                }
                else
                {
                    int    hash   = hash(seed, i, j + PRIME_Y);
                    int    index1 = hash & (127 << 1);
                    int    index2 = (hash >> 7) & (255 << 1);
                    double xg     = GRAD2[index1];
                    double yg     = GRAD2[index1 | 1];
                    double value  = x1 * xg + y1 * yg;
                    double xgo    = VEC2[index2];
                    double ygo    = VEC2[index2 | 1];
                    xo = value * xgo;
                    yo = value * ygo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }
        else
        {
            double x1 = x0 + (G2 - 1);
            double y1 = y0 + G2;
            double b  = 0.5 - x1 * x1 - y1 * y1;
            if (b > 0)
            {
                double bbbb = (b * b) * (b * b);
                double xo, yo;
                if (outGradOnly)
                {
                    int hash = hash(seed, i + PRIME_X, j) & (255 << 1);
                    xo = VEC2[hash];
                    yo = VEC2[hash | 1];
                }
                else
                {
                    int    hash   = hash(seed, i + PRIME_X, j);
                    int    index1 = hash & (127 << 1);
                    int    index2 = (hash >> 7) & (255 << 1);
                    double xg     = GRAD2[index1];
                    double yg     = GRAD2[index1 | 1];
                    double value  = x1 * xg + y1 * yg;
                    double xgo    = VEC2[index2];
                    double ygo    = VEC2[index2 | 1];
                    xo = value * xgo;
                    yo = value * ygo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
            }
        }
        
        coord.x += vx * warpAmp;
        coord.y += vy * warpAmp;
    }
    
    private void singleDomainWarpOpenSimplex2Gradient(int seed, double warpAmp, double frequency, double x, double y, double z, Vector3 coord, boolean outGradOnly)
    {
        x *= frequency;
        y *= frequency;
        z *= frequency;
        
        /*
         * --- Rotation moved to switch statements before fractal evaluation ---
         * final FNLfloat R3 = (FNLfloat)(2.0 / 3.0);
         * FNLfloat r = (x + y + z) * R3; // Rotation, not skew
         * x = r - x; y = r - y; z = r - z;
         */
        
        int    i  = fastRound(x);
        int    j  = fastRound(y);
        int    k  = fastRound(z);
        double x0 = x - i;
        double y0 = y - j;
        double z0 = z - k;
        
        int xNSign = (int) (-x0 - 1.0) | 1;
        int yNSign = (int) (-y0 - 1.0) | 1;
        int zNSign = (int) (-z0 - 1.0) | 1;
        
        double ax0 = xNSign * -x0;
        double ay0 = yNSign * -y0;
        double az0 = zNSign * -z0;
        
        i *= PRIME_X;
        j *= PRIME_Y;
        k *= PRIME_Z;
        
        double vx, vy, vz;
        vx = vy = vz = 0;
        
        double a = (0.6 - x0 * x0) - (y0 * y0 + z0 * z0);
        for (int l = 0; ; l++)
        {
            if (a > 0)
            {
                double aaaa = (a * a) * (a * a);
                double xo, yo, zo;
                if (outGradOnly)
                {
                    int hash = hash(seed, i, j, k) & (255 << 2);
                    xo = VEC3[hash];
                    yo = VEC3[hash | 1];
                    zo = VEC3[hash | 2];
                }
                else
                {
                    int    hash   = hash(seed, i, j, k);
                    int    index1 = hash & (63 << 2);
                    int    index2 = (hash >> 6) & (255 << 2);
                    double xg     = GRAD3[index1];
                    double yg     = GRAD3[index1 | 1];
                    double zg     = GRAD3[index1 | 2];
                    double value  = x0 * xg + y0 * yg + z0 * zg;
                    double xgo    = VEC3[index2];
                    double ygo    = VEC3[index2 | 1];
                    double zgo    = VEC3[index2 | 2];
                    xo = value * xgo;
                    yo = value * ygo;
                    zo = value * zgo;
                }
                vx += aaaa * xo;
                vy += aaaa * yo;
                vz += aaaa * zo;
            }
            
            double b  = a;
            int    i1 = i;
            int    j1 = j;
            int    k1 = k;
            double x1 = x0;
            double y1 = y0;
            double z1 = z0;
            
            if (ax0 >= ay0 && ax0 >= az0)
            {
                x1 += xNSign;
                b = b + ax0 + ax0;
                i1 -= xNSign * PRIME_X;
            }
            else if (ay0 > ax0 && ay0 >= az0)
            {
                y1 += yNSign;
                b = b + ay0 + ay0;
                j1 -= yNSign * PRIME_Y;
            }
            else
            {
                z1 += zNSign;
                b = b + az0 + az0;
                k1 -= zNSign * PRIME_Z;
            }
            
            if (b > 1)
            {
                b -= 1;
                double bbbb = (b * b) * (b * b);
                double xo, yo, zo;
                if (outGradOnly)
                {
                    int hash = hash(seed, i1, j1, k1) & (255 << 2);
                    xo = VEC3[hash];
                    yo = VEC3[hash | 1];
                    zo = VEC3[hash | 2];
                }
                else
                {
                    int    hash   = hash(seed, i1, j1, k1);
                    int    index1 = hash & (63 << 2);
                    int    index2 = (hash >> 6) & (255 << 2);
                    double xg     = GRAD3[index1];
                    double yg     = GRAD3[index1 | 1];
                    double zg     = GRAD3[index1 | 2];
                    double value  = x1 * xg + y1 * yg + z1 * zg;
                    double xgo    = VEC3[index2];
                    double ygo    = VEC3[index2 | 1];
                    double zgo    = VEC3[index2 | 2];
                    xo = value * xgo;
                    yo = value * ygo;
                    zo = value * zgo;
                }
                vx += bbbb * xo;
                vy += bbbb * yo;
                vz += bbbb * zo;
            }
            
            if (l == 1) break;
            
            ax0 = 0.5 - ax0;
            ay0 = 0.5 - ay0;
            az0 = 0.5 - az0;
            
            x0 = xNSign * ax0;
            y0 = yNSign * ay0;
            z0 = zNSign * az0;
            
            a += (0.75 - ax0) - (ay0 + az0);
            
            i += (xNSign >> 1) & PRIME_X;
            j += (yNSign >> 1) & PRIME_Y;
            k += (zNSign >> 1) & PRIME_Z;
            
            xNSign = -xNSign;
            yNSign = -yNSign;
            zNSign = -zNSign;
            
            seed += 1293373;
        }
        
        coord.x += vx * warpAmp;
        coord.y += vy * warpAmp;
        coord.z += vz * warpAmp;
    }
    
    public static class Vector2
    {
        public double x;
        public double y;
        
        public Vector2(double x, double y)
        {
            this.x = x;
            this.y = y;
        }
    }
    
    public static class Vector3
    {
        public double x;
        public double y;
        public double z;
        
        public Vector3(double x, double y, double z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
}
